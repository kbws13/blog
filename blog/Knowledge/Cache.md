---
id: cache
slug: /cache
title: 缓存穿透、雪崩、击穿问题及其解决方法
date: 2024-03-02
tags: [缓存穿透,缓存雪崩,缓存击穿]
keywords: [缓存穿透,缓存雪崩,缓存击穿]
---
## 缓存穿透
### 定义
缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会直接打到数据库

### 解决方案
常见的解决方案有两种：
 - 缓存空对象
   - 优点：实现简单，维护方便
   - 缺点：
     - 额外的内存消耗
     - 可能造成短期的不一致
 - 布隆过滤
   - 优点：内存占用少，没有多余 Key
   - 缺点：
     - 实现复杂
     - 存在误判的可能

#### 缓存空对象
当客户端访问不存在的数据时，先请求 Redis，但是此时 Redis 中没有数据，此时会访问数据库，但是数据库中也没有这个数据，这个数据穿透了缓存，直击数据库，数据库能承载的并发不如 Redis 那么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库

解决方案就是哪怕这个数据在数据库也不存在，也要把数据存入到 Redis 中，这样下次用户过来访问这个不存在的数据，在 Redis 中就能直接找到，就不会进入数据库了

#### 布隆过滤器
布隆过滤器采用的是哈希的思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的数据是否存在。如果布隆过滤器判断存在，则放行，这个请求会去访问 Redis，哪怕此时 Redis 中的数据过期了，但数据库中一定存在这个数据，在数据库中查出这个数据后，再将其放入 Redis 中；如果布隆过滤器判断这个数据不存在，则直接返回

这种方式优点在于节省内存空间，存在误判，原因是：布隆过滤器走的哈希思想，只要是哈希思想，就可能发生哈希冲突

![20240302201811](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302201811.png)

## 缓存雪崩
### 定义
缓存雪崩是指在同一时段内大量的缓存 Key 同时失效或者 Redis 宕机，导致大量请求到达数据库，带来巨大的压力

### 解决方案
 - 给不同 Key 的 TTL 添加随机值
 - 利用 Redis 集群提供服务的可用性
 - 给缓存业务添加降级限流策略
 - 给业务添加多级缓存

![20240302202102](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302202102.png)

## 缓存击穿
### 定义
缓存击穿问题，也叫热点 Key 问题，就是一个被高并发访问并且缓存重建业务较复杂的 Key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的压力

#### 例子
假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了

但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法，那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

![20240302202414](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302202414.png)

### 解决方案
常见的解决方案有两种
 - 互斥锁
 - 逻辑过期

#### 互斥锁
锁能实现互斥性，假设线程过来，只能一个一个的访问数据库，从而避免了数据库访问压力过大，但这也会影响查询的性能，因此此时会让查询的性能从并行变成了串行

可以采用`TryLocy 方法 + Double Lock`来解决这个问题

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑

假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了

![20240302202708](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302202708.png)

#### 逻辑过期
之所以会出现缓存击穿问题，是因为对 Key 设置了过期时间，假设不设置过期时间，其实就不会有缓存击穿问题；同时为了避免数据一直占用内存，可以采用逻辑过期方案：

把数据的过期时间设置在 Redis 的 Value 中，**注意：这个过期时间并不会直接作用与 Redis**，而是后续通过逻辑去处理的

假设线程1去查询缓存，然后从 Value 中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程就会开启一个线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回

假设现在线程3过来访问，由于线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据

![20240302203058](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302203058.png)

### 对比
**互斥锁**：由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响

**逻辑过期**：线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

![20240302203201](https://blog-1312417182.cos.ap-chengdu.myqcloud.com/blog/20240302203201.png)



