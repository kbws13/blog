# 多态性
对象的多态性：父类的引用指向子类的对象

```java
Person p =new Man( );
//Person为父类，Man为子类
```
多态的使用：当调用子父类同名的方法时，实际执行的是子类重写父类的方法-------虚拟方法调用

有了对象的多态性之后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

多态性的使用前提：①类的继承关系 ②方法的重写

==多态是一种运行时行为==

==注：对象的多态性只适用于方法，不适用于属性==

**有了对象的多态性之后，内存中实际加载了子类所特有的属性和方法，但由于变量声明为父类类型，导致编译时只能调用父类的属性和方法。子类特有的属性和方法不能调用。**

虚拟方法调用：正常方法调用：

```java
Person e=new Person( );
e.getInfo( );
Student e=new Student( );
e.getInfo( );
```
虚拟方法调用（多态情况下）：子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法在编译期是无法确定的。

```java
Person e=new Student( );
e.getInfo( );         //调用Student类的getInfo（）方法
```
#### 编译时类型和运行时类型：

编译时e为Person类型，而方法的调用时在运行时确定的，所有调用的是Student类型的getInfo（）方法。----动态绑定

#### 如何使用子类特有的属性和方法？

向下转型：使用强制类型转换符：

```java
Person p2=new Man();
Man m1=(Man)p2;
```
![image-20220719102735041](%E5%A4%9A%E6%80%81%E6%80%A7.assets/image-20220719102735041.png)

使用强制转换时可能会出现ClassCastException异常