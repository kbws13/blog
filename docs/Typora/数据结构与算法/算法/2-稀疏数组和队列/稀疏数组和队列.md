# 稀疏数组

一个实际需求

编写的五子棋程序中，有存盘和续上盘的功能

![image-20230126223749460](%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97.assets/image-20230126223749460.png)

分析问题：因为该二维数组的很多值是默认0，因此记录了很多没有意义的数据->稀疏数组

## 基本介绍

当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法是:

1)记录数组一共有几行几列，有多少个不同的值

2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

例子：

![image-20230126224115954](%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97.assets/image-20230126224115954.png)

## 应用实例

1. 使用稀疏数组，来保留类似前面的二维数组（棋盘、地图等）

2. 把稀疏数组存盘，并且可以重新恢复原来的二维数组数

3. 整体思路分析![image-20230127190638200](%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97.assets/image-20230127190638200.png)

    二维数组转稀疏数组：

    1. 遍历原始二维数组，得到有效数据的个数sum
    2. 根据sum创建稀疏数组sparseArr int[sum+1] [3]
    3. 将二维数组的有效数据存入到稀疏数组中

    稀疏数组转原始二维数组：

    1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr2 = int[11] [11]
    2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组

4. 代码实现：

    ```java
    package xyz.kbws.sparsearray;
    
    import java.io.*;
    
    /**
     * @author hsy
     * @date 2023/1/27
     */
    public class SparseArray {
        public static void main(String[] args) {
            //创建原始的二维数组11*11
            //0：没有棋子，1：黑子，2：蓝子
            int [][]chessArr1 = new int[11][11];
            chessArr1[1][2] = 1;
            chessArr1[2][3] = 2;
            //输出原始的二维数组
            for (int[] row : chessArr1) {
                for (int data : row){
                    System.out.printf("%d\t",data);
                }
                System.out.println();
            }
            //将二维数组转稀疏数组
            //1.先遍历二维数组，得到非0数据的个数
            int sum = 0;
            for (int i = 0; i < 11; i++) {
                for (int j = 0; j < 11; j++) {
                    if(chessArr1[i][j]!=0){
                        ++sum;
                    }
                }
            }
            //2.创建对应的稀疏数组
            int[][] sparseArr = new int[sum+1][3];
            //给稀疏数组赋值
            sparseArr[0][0] = 11;
            sparseArr[0][1] = 11;
            sparseArr[0][2] = sum;
            //遍历二维数组，将非0数据存放到sparseArr中
            int count = 0;//用于记录是第几个非0数据
            for (int i = 0; i < 11; i++) {
                for (int j = 0; j < 11; j++) {
                    if(chessArr1[i][j]!=0){
                        count++;
                        sparseArr[count][0] = i;
                        sparseArr[count][1] = j;
                        sparseArr[count][2] = chessArr1[i][j];
                    }
                }
            }
            //输出稀疏数组的形式
            System.out.println();
            System.out.println("得到的稀疏数组为：");
            for (int[] ints : sparseArr) {
                System.out.printf("%d\t%d\t%d\t\n", ints[0], ints[1], ints[2]);
            }
            System.out.println();
            //将稀疏数组恢复成原始二维数组
            //1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
            int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
            //2.在读取稀疏数组后几行的数据，并赋给原始的二维数组
            for (int i = 1; i < sparseArr.length; i++) {
                chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
            }
            for (int[] row : chessArr2) {
                for (int data : row){
                    System.out.printf("%d\t",data);
                }
                System.out.println();
            }
            System.out.println("开始写入文件>>>>>>>>>>>>>>>>>>>");
            BufferedWriter writer = null;
            try {
                writer = new BufferedWriter(new FileWriter("./map.txt"));
                for (int i = 0; i < sparseArr.length; i++) {
                    for (int j = 0; j < sparseArr[0].length; j++) {
                        writer.write(sparseArr[i][j]+"\t");
                    }
                    writer.newLine();
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }finally {
                if(writer!=null){
                    try {
                        writer.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            System.out.println("写入文件成功>>>>>>>>>>>>>>>>>>>");
            //读取文件
            BufferedReader bf = null;
            int readRow = 0;//统计行数
            int[][] sparseArr2 = new int[count+1][3];
            try {
                bf = new BufferedReader(new FileReader("./map.txt"));
                String line = null;
                //统计行数
                while ((line = bf.readLine())!=null){
                    String[] temp = line.split("\t");
                    for (int i = 0; i < temp.length; i++) {
                        sparseArr2[readRow][i] = Integer.parseInt(temp[i]);
                    }
                    readRow++;
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            } finally {
                if(bf!=null){
                    try {
                        bf.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            System.out.println("从磁盘读取的稀疏数组为：");
            for (int i = 0; i < sparseArr2.length; i++) {
                System.out.printf("%d\t%d\t%d\t\n",sparseArr2[i][0],sparseArr2[i][1],sparseArr2[i][2]);
            }
        }
    }
    ```

   



# 队列

## 介绍

队列是一个有序列表，可以用数组或者是链表来实现

遵循先入先出的规则，即：先存入队列的数据，要先取出。后存入的要后取出

示意图：

![image-20230127210257889](%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97.assets/image-20230127210257889.png)

## 数组模拟队列

队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图

因为队列的输出、输入是分别从前后端来处理，因此需要两个遍历front和rear分别记录队列前后端的下标，front会随数据的输出而改变，而rear会随着数据的输入而改变

当将数据存入队列时称为`addQueue`，addQueue需要处理两个步骤

1. 将尾指针往后移，rear+1，当front==rear时队列为空
2. 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据，当rear==maxSize-1时队列已满。

### 代码实现

```java
package xyz.kbws.queue;

import java.util.Scanner;

/**
 * @author hsy
 * @date 2023/1/28
 */
public class ArrayQueueDemo {
    public static void main(String[] args) {
        ArrayQueue arrayQueue = new ArrayQueue(30);
        char key = ' ';//接收用户输入
        Scanner in = new Scanner(System.in);
        boolean loop = true;
        //输出菜单
        while (loop){
            System.out.println("s(show):");
            System.out.println("e(exit):");
            System.out.println("a(add):");
            System.out.println("g(get):");
            System.out.println("h(head):");
            key = in.next().charAt(0);
            switch (key){
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'e':
                    in.close();
                    loop=false;
                    break;
                case 'a':
                    System.out.print("输入一个数:");
                    int value = in.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try {
                        int res = arrayQueue.getQueue();
                        System.out.printf("取出的数据为:%d",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int res = arrayQueue.headQueue();
                        System.out.printf("队列的头数据为:%d",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                default:
                    break;
            }
        }
    }
}
//使用数组模拟队列
class ArrayQueue{
    private int maxSize;//数组最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//用于存放数据，模拟队列
    //创建队列构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部，front指向队列头的前一个位置
        rear = -1;//指向队列尾部，指向队列尾的数据
    }
    //判断队列是否满
    public boolean isFull(){
        return rear==maxSize-1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return front==rear;
    }
    //添加数据到队列
    public void addQueue(int n){
        if(isFull()){
            System.out.println("队列已满");
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;
    }
    //获取队列数据
    public int getQueue(){
        //判断队列是否为空
        if(isEmpty()){
            //抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;//front后移
        return arr[front];
    }
    //显示队列所有数据
    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
    //显示队列的头数据
    public int headQueue(){
        //判断队列是否为空
        if(isEmpty()){
            //抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        return arr[front+1];
    }
}
```

## 数组模拟环形队列

之前队列数组只能使用一次，不能重复使用，可以将其优化为环形队列

分析：

1. front指向队列的第一个元素，初始值为0

2. rear指向队列最后一个元素的后一个位置，用于空出一个空间作为约定，初始值为0

3. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定

    注意：`(rear+1)%maxSize==front`的时候队列已满

4. `rear==front`时队列为空

5. 队列中有效数据的个数：`(rear+maxSize-front)%maxSize //rear=1 front=0`

