# 概念

递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时让代码变得简洁

# 调用机制

## 打印问题

```java
public static void test(int n){
    if(n>2){
        test(n-1);
    }
    System.out.println("n="+n);
} 
```

## 阶乘

```java
public static int factorial(int n){
    if(n==1){
        return 1;
    }else{
        return factorial(n-1)*n;
    }
}
```

## 递归调用规则

1. 当一个程序执行到一个方法时，就会开辟一个独立的空间
2. 每个空间的数据（局部变量），是独立的

![image-20230212122337894](%E9%80%92%E5%BD%92.assets/image-20230212122337894.png)



# 解决的问题

1. 数学问题：8皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题
2. 各种算法中也会用到递归，比如快速排序、归并排序、二分查找、分治算法等
3. 将用栈解决问题->递归代码比较简洁

# 遵循的原则

1. 执行一个方法，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会相互影响
3. 递归必须向退出递归的条件逼近，否则会无限递归，出现`StackOverflowError`
4. 当一个方法执行完毕，或者遇到return，就会返回，遵循谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕了



# 迷宫问题

![image-20230212130708208](%E9%80%92%E5%BD%92.assets/image-20230212130708208.png)

```java
package xyz.kbws.recursion;

/**
 * @author hsy
 * @date 2023/2/12
 */
public class MiGong {
    public static void main(String[] args) {
        //先创建一个二维数组，模拟迷宫
        //地图
        int[][] map = new int[8][7];
        //使用1表示墙，上下全部置为1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
            
        }
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置挡板
        map[3][1] = 1;
        map[3][2] = 1;
        //输出地图
        System.out.println("地图情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
        setWay(map,1,1);
        System.out.println("走过的地图");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
    }
    /**
     * 使用递归来给小球找路,如果小球能到map[6][5]位置说明通路找到
     * 当map[i][j]为0说明该点没有走过，1表示墙，2表示通路可以走，3表示该点已经走过，但是走不通
     * 在走迷宫时，需要确定一个策略 下-》右-》上-》左，如果走不通在回溯
     * @param map 地图
     * @param i 从哪个位置开始找
     * @param j
     * @return 如果找到通路，返回true，否则返回false
     */
    public static boolean setWay(int[][] map,int i,int j){
        if (map[6][5]==2){
            //道路已经找到
            return true;
        }else {
            if (map[i][j]==0){
                //当前这个点还没有走过
                map[i][j] = 2;
                if (setWay(map,i+1,j)){
                    //向下走
                    return true;
                }else if (setWay(map,i,j+1)){
                    //向右走
                    return true;
                }else if (setWay(map,i-1,j)){
                    //向上走
                    return true;
                }else if (setWay(map,i,j-1)){
                    //向左走
                    return true;
                }else {
                    //说明该点走不通
                    map[i][j] = 3;
                    return false;
                }
            }else {
                return false;
            }
        }
    }
}
```







# 八皇后问题(回溯算法)

![image-20230212153619178](%E9%80%92%E5%BD%92.assets/image-20230212153619178.png)

## 思路分析

![image-20230212155035154](%E9%80%92%E5%BD%92.assets/image-20230212155035154.png)

用一维数组解决问题，`arr[8]={0,4,7,5,2,6,1,3}`，`arr[i]=val`表示第`i+1`个皇后，放在第`i+1`行的第`val+1`列

代码：

```java
package xyz.kbws.recursion;

/**
 * @author hsy
 * @date 2023/2/12
 */
public class Queue8 {
    //定义一个max表示一共有多少个皇后
    int max = 8;
    //定义数组，保存皇后放置位置的结果
    int[] array = new int[max];
    static int count = 0;
    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.println("一个有"+count+"种解法");
    }
    //放置皇后
    public void check(int n){
        if (n==max){
            print();
            return;
        }
        for (int i = 0; i < max; i++) {
            array[n]=i;
            //放置第n个皇后到第i列
            if (judge(n)){
                check(n+1);
            }
        }
    }
    //检测放置的皇后位置是否冲突
    public boolean judge(int n){
        for (int i = 0; i < n; i++) {
            if (array[i]==array[n]||Math.abs(n-i)==Math.abs(array[n]-array[i])){
                return false;
            }
        }
        return true;
    }
    //输出皇后位置
    public void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+" ");
        }
        System.out.println();
    }
}
```



