# 链表（Linked List）介绍

链表是有序的列表，但是他在内存中的存储如下：

![image-20230128180317546](%E9%93%BE%E8%A1%A8.assets/image-20230128180317546.png)

1. 链表是以节点的方式来存储
2. 每个节点包含data域， next域:指向下一个节点
3. 链表的各个节点不一定是连续存放
4. 链表分带头结点和不带头结点，根据实际需求来确定

![image-20230128180549534](%E9%93%BE%E8%A1%A8.assets/image-20230128180549534.png)



# 单链表

## 应用实例

使用带head头的单向链表实现-水浒英雄排行榜管理

1. 完成对英雄人物的增删改查操作
2. 第一种方法在添加英雄时，直接添加到链表的尾部
3. 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)

添加（创建）：

1. 先创建一个head节点，作用是表示单链表的头
2. 后面每添加一个节点，就直接加入到链表的最后

遍历：

通过一个辅助遍历，帮助遍历整个链表

代码：

### 添加到链表尾部

```java
package xyz.kbws.linkedlist;

/**
 * @author hsy
 * @date 2023/1/28
 */
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode heroNode1 = new HeroNode(1,"宋江","及时雨");
        HeroNode heroNode2 = new HeroNode(2,"林冲","豹子头");
        HeroNode heroNode3 = new HeroNode(3,"卢俊义","玉麒麟");

        SingleLinkedList linkedList = new SingleLinkedList();
        linkedList.add(heroNode1);
        linkedList.add(heroNode2);
        linkedList.add(heroNode3);

        linkedList.list();
    }
}
//定义SingleLinkedList
class SingleLinkedList{
    //初始化头节点，不存放头节点
    private HeroNode head = new HeroNode(0,"","");
    //添加节点
    //不考虑编号顺序时，找到当前链表的最后节点，将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        HeroNode temp = head;
        //遍历
        while (true){
            if(temp.next==null){
                break;
            }
            temp = temp.next;
        }
        temp.next = heroNode;
    }
    //遍历链表
    public void list(){
        //判空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode temp = head.next;
        while (true){
            if (temp==null){
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
}

//定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName +
                '}';
    }
}
```

### 按顺序插入节点

思路分析：

1. 找到新添加的节点的位置，通过辅助变量（指针temp），通过遍历搞定
2. 新的节点`新节点的next=temp.next`
3. 将`temp.next=新的节点`

```java
//按照序号添加节点
public void addByOrder(HeroNode heroNode){
    HeroNode temp = head;//辅助指针
    boolean flag = false;//标志编号是否存在
    while (true){
        if (temp.next==null){
            break;
        }
        if (temp.next.no>heroNode.no){
            break;
        } else if (temp.next.no == heroNode.no) {
            flag=true;//说明编号存在
            break;
        }
        temp = temp.next;
    }
    //判断flag的值
    if (flag){
        System.out.printf("准备插入的编号%d已经存在了",heroNode.no);
    }else {
        //插入到temp后面
        heroNode.next = temp.next;
        temp.next = heroNode;
    }
}
```

### 修改

```java
//修改节点信息，根据编号来修改
public void update(HeroNode heroNode){
    if(head.next==null){
        System.out.println("链表为空");
        return;
    }
    //找到需要修改的编号
    HeroNode temp = head.next;//辅助变量
    boolean flag = false;//表示是否找到该节点
    while (true){
        if (temp==null){
            break;//已经遍历完链表
        }
        if (temp.no==heroNode.no){
            flag=true;
            break;
        }
        temp = temp.next;
    }
    //根据flag判断是否找到
    if (flag){
        temp.name = heroNode.name;
        temp.nickName = heroNode.nickName;
    }else {
        //没有找到
        System.out.println("没有找到编号"+heroNode.no+"的节点");
    }
}
```

### 删除

思路：

1. 先找到需要删除节点的前一个节点temp
2. `temp.next=temp.next.next`
3. 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收

```java
//删除节点
public void delete(int no){
    HeroNode temp = head;
    boolean flag = false;
    while (true){
        if (temp.next==null){
            break;
        }
        if (temp.next.no==no){
            flag = true;
            break;
        }
        temp = temp.next;
    }
    if (flag){
        temp.next = temp.next.next;
    }
    else {
        System.out.println("要删除的节点"+no+"不存在");
    }
}
```

## 面试题

求单链表中节点的个数

```java
/**
 * 链表节点个数
 * @param head
 * @return
 */
public static int getLength(HeroNode head){
    if(head.next==null){
        return 0;
    }
    int length=0;
    //定义一个辅助变量
    HeroNode cur = head.next;
    while (cur!=null){
        length++;
        cur = cur.next;
    }
    return length;
}
```



查找单链表中的倒数第k个节点

```java
/**
 * 查找链表的倒数第k个节点
 * @param head
 * @param index
 * @return
 */
public static HeroNode findLastIndexNode(HeroNode head,int index){
    if (head.next==null){
        return null;
    }
    int size = getLength(head);
    if(index<=0||index>size){
        return null;
    }
    //定义辅助变量
    HeroNode cur = head.next;
    for (int i = 0; i < size - index; i++) {
        cur = cur.next;
    }
    return cur;
}
```



单链表的反转

思路：

1. 先定义一个节点`reverseHead = new HeroNode();`
2. 从头到尾遍历原来的链表，没遍历一个链表就将其取出，放在新的链表`reverseHead`的最前端
3. 原来的链表的`head.next=reverseHead.next`

```java
/**
     * 反转单链表
     * @param head
     */
public static void reversetList(HeroNode head){
    //判空
    if(head.next==null||head.next.next==null){
        return;
    }
    //定义辅助指针
    HeroNode cur = head.next;
    HeroNode next = null;//指向当前节点的下一个节点
    HeroNode reverseHead = new HeroNode(0,"","");
    while (cur!=null){
        next = cur.next;
        cur.next = reverseHead.next;
        cur = next;
    }
    head.next = reverseHead.next;
}
```





从尾到头打印单链表（方式1：反向遍历，方式2：Stack栈）

思路：

1. 方式一：将单链表进行反转操作，然后再遍历就行，但这样会破坏单链表的结构
2. 方式二：将各个节点压入栈中，利用栈先入先出的特点

```java
/**
     * 逆序打印
     * @param head
     */
public static void reversePrint(HeroNode head){
    if (head.next==null){
        return;
    }
    //创建栈
    Stack<HeroNode> stack = new Stack<>();
    HeroNode cur = head.next;
    //压栈
    while (cur!=null){
        stack.push(cur);
        cur = cur.next;
    }
    //出栈，打印
    while (stack.size()>0){
        System.out.println(stack.pop());
    }
}
```



# 双向链表

单向链表的缺点分析:

1)单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。

2)单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删

除时节点，总是找到temp的下一个节点来删除的(认真体会)

双向链表的遍历，添加，修改，删除的操作思路：

1. 遍历方法和单链表一样，向前向后都可以
2. 添加（默认添加到双向链表的最后）
    1. 先找到双向链表的最后一个节点
    2. `temp.next=newHeroNode`
    3. `newHeroNode.pre=temp`
3. 修改和单链表一样
4. 因为是双向链表，因此可以自我删除某个节点
    1. 直接找到要删除的节点，比如temp
    2. `temp.pre.next=temp.next`
    3. `temp.next.pre=temp.pre`

```java
package xyz.kbws.linkedlist;

/**
 * @author hsy
 * @date 2023/2/4
 */
public class DoubleLinkedListDemo {

}

//创建一个双向链表类
class DoubleLinkedList{
    private HeroNode2 head = new HeroNode2(0,"","");
    public HeroNode2 getHead(){
        return head;
    }

    //遍历链表
    public void list(){
        //判空
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.next;
        while (true){
            if (temp==null){
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
    //添加节点
    public void add(HeroNode2 heroNode){
        HeroNode2 temp = head;
        //遍历
        while (true){
            if(temp.next==null){
                break;
            }
            temp = temp.next;
        }
        temp.next = heroNode;
        heroNode.pre = temp;
    }
    //修改节点信息，根据编号来修改
    public void update(HeroNode2 heroNode){
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的编号
        HeroNode2 temp = head.next;//辅助变量
        boolean flag = false;//表示是否找到该节点
        while (true){
            if (temp==null){
                break;//已经遍历完链表
            }
            if (temp.no==heroNode.no){
                flag=true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到
        if (flag){
            temp.name = heroNode.name;
            temp.nickName = heroNode.nickName;
        }else {
            //没有找到
            System.out.println("没有找到编号"+heroNode.no+"的节点");
        }
    }
    //删除节点
    public void delete(int no){
        if(head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true){
            if (temp==null){
                break;
            }
            if (temp.no==no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.pre.next=temp.next;
            if (temp.next!=null) {
                temp.next.pre = temp.pre;
            }
        }
        else {
            System.out.println("要删除的节点"+no+"不存在");
        }
    }
}

//定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode2{
    public int no;
    public String name;
    public String nickName;
    public HeroNode2 next;
    public HeroNode2 pre;

    public HeroNode2(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName +
                '}';
    }
}
```





# 单向环形链表

## Josephu(约瑟夫、约瑟夫环)问题

设编号为1，2，。。。n的n个人围坐在一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，她的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人都出列为止，由此产生一个出队编号的序列

提示：用一个不带头节点的循环链表来处理Josephu问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，直到最后一个节点从链表中删除，算法结束

构建单向环形链表思路：

1. 先创建第一个节点，让first指向该节点，并形成环形
2. 后面当我们每创建一个新节点，就把该节点加入到已有的环形链表中即可

遍历环形链表

1. 先让一个辅助指针（变量），指向first节点，报数前，先让first和helper移动k-1次
2. 然后通过while循环遍历该环形链表即可，`curBoy.next==first`结束

解题思路：

1. 需求创建一个辅助指针（变量）helper，事先应该指向环形链表的最后一个节点
2. 当报数时，让first和helper指针同时移动m-1次
3. 这时可以将first指向的节点移除`first=first.next; helper.next=first;`

代码

```java
package xyz.kbws.linkedlist;

/**
 * @author hsy
 * @date 2023/2/9
 */
public class Josephu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        circleSingleLinkedList.countBoy(1,2,5);
    }
}

//创建一个环形的单向链表
class CircleSingleLinkedList{
    //创建一个头节点first，当前没有编号
    private Boy first = new Boy(-1);
    //添加节点
    public void addBoy(int nums){
        //nums做一个数据校验
        if (nums<1){
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy = null;//辅助指针，帮助构建环形链表
        for (int i = 1; i <= nums; i++) {
            //根据编号创建节点
            Boy boy = new Boy(i);
            //如果是第一个节点
            if (i==1){
                first = boy;
                first.setNext(first);
                curBoy = first;//让curBoy指向第一个节点
            }else {
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;
            }
        }
    }
    //遍历链表
    public void showBoy(){
        //判断是否为空
        if (first==null){
            System.out.println("链表为空");
            return;
        }
        Boy curBoy = first;
        while (true){
            System.out.println("编号为"+curBoy.getNo());
            if (curBoy.getNext()==first){
                //遍历完成
                break;
            }
            curBoy = curBoy.getNext();
        }
    }
    /**
     * 根据用户输入，计算出圈顺序
     * @param startNo 从第几个开始数
     * @param countNum 表示数几下
     * @param nums 有多少个节点
     */
    public void countBoy(int startNo,int countNum,int nums){
        //数据校验
        if (first==null||startNo<1||startNo>nums){
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        //创建辅助指针，让其指向环形链表最后的节点
        Boy helper = first;
        while (true){
            if (helper.getNext()==first){
                break;
            }
            helper = helper.getNext();
        }
        for (int i = 0; i < startNo - 1; i++) {
            first=first.getNext();
            helper=helper.getNext();
        }
        while (true){
            if (helper==first){
                //只有一个节点时
                break;
            }
            for (int i = 0; i < countNum - 1; i++) {
                first=first.getNext();
                helper=helper.getNext();
            }
            //这时first指向的节点，就是要出圈的节点
            System.out.println(first.getNo()+"出圈");
            //出圈
            first=first.getNext();
            helper.setNext(first);
        }
        System.out.println("最后留在圈中节点的编号为"+helper.getNo());
    }
}

//创建一个Boy类，表示一个节点
class Boy{
    private int no;
    private Boy next;
    public Boy(int no){
        this.no = no;
    }
    public int getNo() {
        return no;
    }
    public void setNo(int no) {
        this.no = no;
    }
    public Boy getNext() {
        return next;
    }
    public void setNext(Boy next) {
        this.next = next;
    }
}
```

