# 介绍

![image-20230213154001699](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230213154001699.png)



# 算法的时间复杂度

两种方法：

1. 事后统计方法：这个方法可行，但是有两个问题：一是想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等因素
2. 事前预估方法：通过分析某个算法的时间复杂度来判断哪个算法更优



## 时间频度

基本介绍：

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句的执行次数较多，它花费的时间就多。一个算法中语句的执行次数称为语句频度或时间频度。记为`T(n)`。

案例：

```java
int total = 0;
int end = 100;
for(int i=0;i<=end;i++){
    total+=i;
}

T(n) = n+1;
for循环执行100次后还要进行判断i<=end所有最后执行的次数是n+1次
```

```java
total = (1+end)*end/2;

T(n) = 1;
程序只执行了一次
```

特点：

1. 忽略常数项
2. 忽略低次项
3. 忽略系数

## 时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用`T(n)`表示，若有某个辅助函数`f(n)`，使得当n趋于无穷大的时候，`T(n)/f(n)`的极限值为不等于零的常数，则称`f(n)`是`T(n)`的同数量级函数。记作`T(n)=O(f(n))`，称`O(f(n))`为算法的渐进时间复杂度，简称时间复杂度
2. `T(n)`不同，时间复杂度可能相同。如T(n)=$n^2$+7n+6与T(n)=$3n^2+2n+2$他们的T(n)不同但是时间复杂度相同，都为$O(n^2)$
3. 计算时间复杂度的方法：
    - 用常数1代替运行时间中的所有加法常数
    - 修改后的运行次数函数中，只保留最高阶项
    - 去除最高阶项的系数

## 常见的时间复杂度

![image-20230213172630561](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230213172630561.png)

常数阶O(1)

```java
int i=1;
int j=2;
++i;
j++;
int m = i+j;
```

对数阶$O(log_2n)$

```java
int i=1;
while(i<n){
    i=i*2;
}
```

说明：在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x次之后，i就

大于2了，此时这个循环就退出了，也就是说2的x次方等于n，那么x=$log_2n$也就是说当循环$log_2n$次以

后，这个代码就结束了。因此这个代码的时间复杂度为$:O(log_2n)$。$O(log_2n)$的这个2时间上是根据代码变化的，i=i* 3，则是$O(log_3n)$。

线性阶O(n)

```java
for(i=1;i<=n;++i){
    j=i;
    j++;
}
```

说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这

类代码都可以用O(n)来表示它的时间复杂度

线性对数阶$O(nlogN)$

```java
for(m=1;m<n;m++){
    i=1;
    while(i<n){
        i=i*2;
    }
}
```

说明:线性对数阶$O(nlogN)$其实非常容易理解，将时间复杂度为$O(logn)$的代码循环N遍的话，那么它

的时间复杂度就是$n*O(logN)$，也就是了$O(nlogN)$

平方阶$O(n^2)$

```java
for(x=1;i<=n;x++){
    for(i=1;i<=n;i++){
        j=i;
        j++;
    }
}
```

说明：平方阶$O(n^2)$就更容易理解了，如果把O(n)的代码再嵌套循环一遍，它的时间复杂度就是$O(n^2)$，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是$O(n*n)$，即$O(n^2)$如果将其中一层循环的n改成m，那它的时间复杂度就变成了$O(m*n)$



立方阶$O(n^3)$、K次方阶$O(n^k)$

参考上面

## 平均复杂度和最坏复杂度

![image-20230213174346918](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230213174346918.png)

# 算法的空间复杂度

## 基本介绍

1. 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
2. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
3. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.



# 冒泡排序

## 基本介绍

冒泡排序(Bubble Sorting）的基本思想是:通过对待排序序列从前向后(从下标较小的元素开始）,依次比

较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

因为排序的过程中，各元素不断接近自己的位置，**如果一趟比较下来没有进行过交换，就说明序列有**

**序**，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。

演示冒泡：

![image-20230213194234589](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230213194234589.png)

## 应用实例

将五个无序的数：3，9，-1，10，20.使用冒泡排序将其排成一个从小到大的有序数列

代码：

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/2/14
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {3,9,-1,10,-2};
        int temp = 0;//临时变量
        for (int i = 0; i < arr.length-1; i++) {
            for (int j = 0; j < arr.length-1-i; j++) {
                if (arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}
```





# 选择排序

## 基本介绍

选择排序属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的

基本思想：

一次从arr[0]~arr[n-1]中选取最小值，与arr[o]交换，第二次从arr[1] ~ arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2] ~ arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1] ~ arr[n-1]中选取最小值，与arr[i-1]交换，…，第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

思路分析图：

![image-20230220191731195](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230220191731195.png)

代码：

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/2/20
 */
public class SelectSort {
    public static void main(String[] args) {
        int[] arr = {101,34,119,1};
        selectSort(arr);
    }
    public static void selectSort(int[] arr){
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i+1; j < arr.length; j++) {
                if (min>arr[j]){
                    min = arr[j];
                    minIndex = j;
                }
            }
            if (minIndex!=i){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}
```





# 插入排序

介绍：

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到配许的目的

## 基本思想

把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中只包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表怨怒是的排序码进行比较，将它插入到有序表中的适当位置

思路图：

![image-20230220201442543](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230220201442543.png)

代码：

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/2/20
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] arr = {101,34,119,1};
        insertSort(arr);
    }
    public static void insertSort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            //定义待插入的数
            int insertVal = arr[i];
            int insertIndex = i-1;
            //找到插入位置
            while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                arr[insertIndex+1] = arr[insertIndex];
                insertIndex--;
            }
            arr[insertIndex+1] = insertVal;
            System.out.println(Arrays.toString(arr));
        }
    }
}
```







# 希尔排序

## 基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量的逐渐减少，每组包含的关键字越来越多，当增量减至1时，整个文件被分成一组，算法便终止

![image-20230223193106870](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230223193106870.png)



代码

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/2/23
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr= {8,9,1,7,2,3,5,4,6,0};
        shellSort2(arr);
    }
    //交换法
    public static void shellSort(int[] arr){
        int temp = 0;
        for (int gap = arr.length; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    //交换
                    if (arr[j]>arr[j+gap]){
                        temp = arr[j];
                        arr[j] = arr[j+gap];
                        arr[j+gap] = temp;
                    }
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
    //位移法
    public static void shellSort2(int[] arr){
        for (int gap = arr.length/2; gap > 0; gap /= 2) {
            //从第gap个元素，逐个对其所在的组进行插入排序
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[i]<arr[j-gap]){
                    while (j-gap >= 0&&temp<arr[j-gap]){
                        //移动
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                    //退出while后，给temp找到插入的位置
                    arr[j] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}
```





# 快速排序

## 基本思想

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按照此方法对两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序数列

## 应用实例

对`[-9,78,0,23,-567,70]`进行从小到大的排序



示意图

![image-20230310200948028](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230310200948028.png)

代码实现：

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/3/10
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {-9,78,0,23,-567,70};
        quickSort(arr,0,arr.length-1);
        System.out.println("arr="+ Arrays.toString(arr));
    }
    public static void quickSort(int[] arr,int left,int right){
        int l = left;//左下标
        int r = right;//右下标
        //中轴值
        int pivot = arr[(left+right)/2];
        int temp;//临时变量
        //while循环使得比pivot小的值到左边，大的值到右边
        while (l<r){
            //在pivot左边一直找，找到大于等于pivot的值
            while (arr[l]<pivot){
                l += 1;
            }
            //在pivot右边一直找，找到小于等于pivot的值
            while (arr[r]>pivot){
                r -= 1;
            }
            //如果l>r说明pivot的左右两边的值，已经按照左边都是小于pivot右边都是大于pivot
            if (l>=r){
                break;
            }
            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            if (arr[l] == pivot){
                r -= 1;
            }
            if (arr[r] == pivot){
                l += 1;
            }
        }
        //避免栈溢出
        if (l==r){
            l += 1;
            r -= 1;
        }
        //向左递归
        if (left<r){
            quickSort(arr,left,r);
        }
        //向右递归
        if (right>l){
            quickSort(arr,l,right);
        }
    }
}
```

# 归并排序

## 基本思想

![image-20230311103728735](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230311103728735.png)

![image-20230311103801794](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230311103801794.png)

## 代码实现

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/3/11
 */
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {8,4,5,7,1,3,6,2};
        int[] temp = new int[arr.length];
        mergeSort(arr,0,arr.length-1,temp);
        System.out.println("排序结果:"+ Arrays.toString(arr));
    }
    //分+合方法
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if (left<right){
            int mid = (left+right)/2;//中间索引
            //向左递归进行分解
            mergeSort(arr, left, mid, temp);
            //向右递归进行分解
            mergeSort(arr, mid+1, right, temp);
            //合并
            merge(arr,left,mid,right,temp);
        }
    }
    /**
     * 合并方法
     * @param arr 排序的原始数组
     * @param left 左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边索引
     * @param temp 做中转的数组
     */
    public static void merge(int[] arr,int left,int mid, int right,int[] temp){
        int i = left;//左边有序序列的初始索引
        int j = mid + 1;//右边序列的初始索引
        int t = 0;//指向temp数组的当前索引
        //1.先把左右两边的数据按照规则填充到temp中，直到左右两边的有序序列，有一边处理完毕为止
        while (i <= mid && j <= right){
            //当左边数据小于右边时
            if (arr[i]<arr[j]){
                temp[t] = arr[i];
                t++;
                i++;
            }else {
                temp[t] = arr[j];
                t++;
                j++;
            }
        }
        //2.把有剩余数据的一边的数据依次全部填充到temp中
        while (i<=mid){
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j<=right){
            temp[t] = arr[j];
            t++;
            j++;
        }
        //3.将temp数组的元素拷贝的arr
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right){
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }
    }
}
```

# 基数排序(桶排序)

## 基本思想

将所有待比较的数值统一为统一的数位长度，数位较短的前面补0.然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序数列

## 代码实现

```java
package xyz.kbws.sort;

import java.util.Arrays;

/**
 * @author hsy
 * @date 2023/3/11
 */
public class RadixSort {
    public static void main(String[] args) {
        int[] arr = {53,3,542,748,14,214};
        radicSort(arr);
    }
    //基数排序方法
    public static void radicSort(int[] arr){

        //1.得出数组中位数最大的数的位数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i]>max){
                max = arr[i];
            }
        }
        //得到最大的数是几位数
        int maxLength = (max+"").length();
        //1.二维数组包含在10个一维数组中
        //2.为了防止数据溢出，每个一维数组大小定义为arr.length
        int[][] bucket = new int[10][arr.length];
        //定义一个一维数组来记录每个桶里每次存放的数据个数
        int[] bucketElementCounts = new int[10];
        //使用对每个元素的个位进行处理
        for (int i = 0,n = 1; i < maxLength; i++,n *= 10) {
            for(int j =0;j< arr.length;j++){
                //取出每个元素个位的值
                int digitOfElement = arr[j] / n % 10;
                //放到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index = 0;
            for(int k =0;k<bucketElementCounts.length;k++){
                if (bucketElementCounts[k]!= 0){
                    for (int l = 0;l<bucketElementCounts[k];l++){
                        arr[index++] = bucket[k][l];
                    }
                }
                bucketElementCounts[k] = 0;
            }
            System.out.println(Arrays.toString(arr));
        }
    }
}
```

注意：

![image-20230311161453655](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230311161453655.png)



# 常用排序算法总结和对比

![image-20230311161515261](%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/image-20230311161515261.png)



1. 在 `find_mid` 函数中，有两个循环分别对数组的左半部分和右半部分进行遍历，时间复杂度为 $O(n)$，其中 $n$ 是子数组的长度。
2. 在 `find_max` 函数中，每次递归将子数组分成两半，因此总的递归深度为 $O(\log n)$，其中 $n$ 是原数组的长度。在每次递归中，调用了一次 `find_mid` 函数，时间复杂度为 $O(n)$，同时进行了三次递归，因此总的时间复杂度为 $O(n \log n)$。

因此，整个代码的时间复杂度为 $O(n \log n)$。
