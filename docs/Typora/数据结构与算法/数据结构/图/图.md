 ![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70.png)

# 图的基本定义的和术语

# 图的基本概念

图（graph）并不是指图形图像（image）或地图（map）。通常来说，我们会把图视为一种由“顶点”组成的抽象网络，网络中的各顶点可以通过“边”实现彼此的连接，表示两顶点有关联。注意上面图定义中的两个关键字，由此得到我们最基础最基本的2个概念，顶点（vertex）和边（edge）。
![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225537217144.png)

如上图所示，节点（vertex）用红色标出，通过黑色的边（edge）连接。

## 度

与结点关联的边数，在有向图中为入度与出度之和。

- 出度：在有向图中以这个结点为起点的有向边的数目。(可形象的理解为离开这个结点的边的数目)
- 入度：在有向图中以这个结点为终点的有向边的数目。(可形象的理解为进入/指向这个结点的边的数目)

> 任意一个图的总度数等于其边数的2倍



## 连通

如果在同一无向图中两个结点存在一条路径相连，则称这两个结点连通。

### 连通图

如果无向图中任意两个结点都是连通的，则称之为连通图。

### 强连通图

如果有向图中任意两个结点之间存在两条路径(即(i,j)两点中，既从i到j有一条路径，j到i也有一条路径)，则两点是强连通的。当一个图中任意两点间都是强连通的，则该图称之为强连通图。

> 在强连通图中，必定有一条回路经过所有顶点。

强连通分量：非强连通图有向图中的最大子强连通图。

## 回路

起点与相同的路径，又叫“环”。

## 完全图

任意两点间都存在边使其相连的无向图或任意两点间都存在两条不同边的有向图称作完全图

N个顶点的完全图:

> 有向 有n(n-1)条边
> 无向 有n(n-1)/2条边

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225694386147.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225701824150.png)

完全图：任意两个点都有一条边相连

无向完全图

n个结点，一共有C(n,2)条边

有向完全图

n(n−1)
![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225723213153.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225734071156.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225745608159.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225751966162.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225762360165.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225768609168.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225776033171.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225782702174.png)



# 图的三种存储结构

## 邻接矩阵表示法

所谓邻接矩阵存储结构就每个顶点用一个一维数组存储边的信息，这样所有点合起来就是用矩阵表示图中各顶点之间的邻接关系。所谓矩阵其实就是二维数组。

```c++
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#define INF 65535
#define MAXVEX 10
using namespace std;
struct MGraph{
    char Vertex[MAXVEX];//顶点集
    int arc[MAXVEX][MAXVEX];//邻接矩阵
    int vexnum;//顶点数量
    int edgenum;//边的数量
};
void Creat(MGraph &g){
    int i,j,k,w;
    cout << "请输入顶点数" <<endl;
    cin >> g.vexnum;
    cout << "请输入边数" <<endl;
    cin >> g.edgenum;
    cout << "请输入顶点数据" <<endl;
    for(i=0;i<g.vexnum;i++){
        cin >> g.Vertex[i];
    }
    //邻接矩阵初始化
    for(i=0;i<g.vexnum;i++){
        for(j=0;j<g.vexnum;j++){
            g.arc[i][j] = INF;
        }
    }
    //读入邻接矩阵信息
    for(k=0;k<g.edgenum;k++){
        cout <<"请输入两个顶点的下标和权值w:";
        cin >> i >> j >> w;
        g.arc[i][j] = w;//赋值
        //有向图不需要下一句
        // g.arc[j][i] = g.arc[i][j];
    }
}

void travle(MGraph &G){
    for(int i=0;i<G.vexnum;i++){
        for(int j=0;j<G.vexnum;j++){
            if(G.arc[i][j]!=INF){
                printf("坐标(%d,%d),权值为:%d\n",i,j,G.arc[i][j]);
            }
        }
    }
    printf("邻接矩阵为:\n");
    for(int i=0;i<G.vexnum;i++){
        for(int j=0;j<G.vexnum;j++){
            printf("%8d",G.arc[i][j]);
        }
        cout << endl;
    }
}
int main(){
    MGraph M;
    Creat(M);
    travle(M);
}
```

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225810337177.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225816707180.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225824338183.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225830301186.png)

## 邻接表(链表)表示法

邻接表：

```c++
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
#define MVNum 100//最大顶点数 
//边
typedef struct ArcNode{ 
    int adjvex;//该边所指向的顶点的位置 
    struct ArcNode * nextarc;//指向下一条边的指针 
    int info;//和边相关的信息 
}ArcNode;
//顶点
typedef struct VNode{ 
    char data;//顶点信息 
    ArcNode * firstarc;//指向第一条依附该顶点的边的指针 
}VNode, AdjList[MVNum];//AdjList表示邻接表类型
//图
typedef struct{ 
    AdjList vertices; 
    int vexnum, arcnum;//图的当前顶点数和边数 
}ALGraph;
//队列
typedef struct QNode{
    int data;
    struct QNode *next;
}QNode,*QueuePtr;
typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;

//确定顶点在图G中的位置
int locate(ALGraph &G,char x){
    for(int i=0;i<G.vexnum;i++){
        if(x==G.vertices[i].data){
            return i;
        }
    }
    return 0;
}
int creatG(ALGraph &G){
    int i,j,k,v1,v2,m=1;
    ArcNode *p1,*p2;
    printf("请输入总顶点数和总边数");
    scanf("%d %d",&G.vexnum,&G.arcnum);
    printf("请输入各顶点的值");
    for(i=0;i<G.vexnum;i++){
        scanf(" %c",&G.vertices[i].data);
        G.vertices[i].firstarc = NULL;
    }
    for(k=0;k<G.arcnum;k++){
        printf("请输入第%d条边的两个顶点:",m);
        m++;
        scanf(" %c %c",&v1,&v2);
        i = locate(G,v1);
        j = locate(G,v2);
        p1 = new ArcNode;
        p1->adjvex = j;
        p1->nextarc = G.vertices[i].firstarc;
        //相当于p1->nextarc = NULL;
        G.vertices[i].firstarc = p1;
    }
}
//标记状态数组
int visited[MVNum]={0};

//深度优先遍历
void DFS (ALGraph &G,int v)
{
    int w=-1;
    if (visited[v])
        return;

    ArcNode *p;

    printf(" %c",G.vertices[v].data);
    visited[v]=true;
    p=G.vertices[v].firstarc;
    while(p!=NULL)
    {
        w=p->adjvex;
        if(visited[w]==false)
            DFS(G,w);
        p=p->nextarc;

    }

}
void DFS_ALL(ALGraph &G)
{
    for (int i=0; i<G.vexnum; i++)
    {
        if (visited[i]==false)
        {
            DFS(G, i);
        }
    }
}

int main(){
    int v,n;
    ALGraph G;
    creatG(G);
    DFS_ALL(G);
}
```

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225856307189.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225861960192.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225867484195.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225873612198.png)



**优点** ：空间效率高，容易寻找顶点的邻接点；

**缺点** ：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。

## 邻接矩阵和邻接表的区别

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225900170201.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668225905793204.png)

# 图的遍历

## 树与图的深度优先遍历及树的一些性质

### 树与图的深度优先遍历

深度优先遍历，就是在每个点x上面的的多条分支时，任意选择一条边走下去，执行递归，直到回溯到点x后再走其他的边

```c++
int vis[N];//标记每一个点的状态

void dfs(int u){
    vis[u] = 1;
    for(int i = head[u];i;i = nex[i]){
        int v = ver[i];
        if(vis[v])
            continue;
        dfs(v);
    }
}
```

### 时间戳

按照上述的深度优先遍历的过程，以每一个结点第一次被访问的顺序，依次赋值1~N的整数标记，该标记就被称为时间戳。
标记了每一个结点的访问顺序。

### 树的DFS

一般来说，我们在对树的进行深度优先时，对于每个节点，在刚进入递归时和回溯前各记录一次该点的编号，最后会产生一个长度为2N的序列，就成为该树的DFS序。

```c++
int a[N],cnt;
int dfs(int u){
     a[++cnt] = u;//用a数组存DFS序
     vis[u] = 1;
     for(int i = head[u]; i;i = nex[i]){
        int v = ver[i];
        if(vis[v])
            continue;
        dfs(v);
     }
     a[++cnt] = u;
}
```

DFS序的特点时：每个节点的x的编号在序列中恰好出现两次。设这两次出现的位置时L[x],R[x]，那么闭区间[ L [ x ] , R [ x ] 就是以x xx为根的子树的DFS序。
dfs序可以把一棵树区间化，即可以求出每个节点的管辖区间。
对于一棵树的dfs序而言，同一棵子树所对应的一定是dfs序中连续的一段。
![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668226111189207.png)

![在这里插入图片描述](%E5%9B%BE.assets/20200522162939859.png)

### 数的BFS

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_VERtEX_NUM 20                   //顶点的最大数量
#define VRType int                          //表示顶点之间关系的数据类型
#define VertexType int                      //顶点的数据类型
typedef enum { false, true }bool;           //定义bool型常量
bool visited[MAX_VERtEX_NUM];               //设置全局数组，记录每个顶点是否被访问过

//队列链表中的结点类型
typedef struct Queue {
    VertexType data;
    struct Queue* next;
}Queue;

typedef struct {
    VRType adj;                             //用 0 表示不相邻，用 1 表示相邻
}ArcCell, AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];

typedef struct {
    VertexType vexs[MAX_VERtEX_NUM];        //存储图中的顶点
    AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
    int vexnum, arcnum;                     //记录图的顶点数和弧（边）数
}MGraph;

//判断 v 顶点在二维数组中的位置
int LocateVex(MGraph* G, VertexType v) {
    int i;
    //遍历一维数组，找到变量v
    for (i = 0; i < G->vexnum; i++) {
        if (G->vexs[i] == v) {
            break;
        }
    }
    //如果找不到，输出提示语句，返回-1
    if (i > G->vexnum) {
        printf("no this vertex\n");
        return -1;
    }
    return i;
}

//构造无向图
void CreateDN(MGraph* G) {
    int i, j, n, m;
    int v1, v2;
    scanf("%d,%d", &(G->vexnum), &(G->arcnum));
    for (i = 0; i < G->vexnum; i++) {
        scanf("%d", &(G->vexs[i]));
    }
    for (i = 0; i < G->vexnum; i++) {
        for (j = 0; j < G->vexnum; j++) {
            G->arcs[i][j].adj = 0;
        }
    }
    for (i = 0; i < G->arcnum; i++) {
        scanf("%d,%d", &v1, &v2);
        n = LocateVex(G, v1);
        m = LocateVex(G, v2);
        if (m == -1 || n == -1) {
            printf("no this vertex\n");
            return;
        }
        G->arcs[n][m].adj = 1;
        G->arcs[m][n].adj = 1;
    }
}

int FirstAdjVex(MGraph G, int v)
{
    int i;
    //对于数组下标 v 处的顶点，找到第一个和它相邻的顶点，并返回该顶点的数组下标
    for (i = 0; i < G.vexnum; i++) {
        if (G.arcs[v][i].adj) {
            return i;
        }
    }
    return -1;
}

int NextAdjVex(MGraph G, int v, int w)
{
    int i;
    //对于数组下标 v 处的顶点，从 w 位置开始继续查找和它相邻的顶点，并返回该顶点的数组下标
    for (i = w + 1; i < G.vexnum; i++) {
        if (G.arcs[v][i].adj) {
            return i;
        }
    }
    return -1;
}

//初始化队列，这是一个有头结点的队列链表
void InitQueue(Queue** Q) {
    (*Q) = (Queue*)malloc(sizeof(Queue));
    (*Q)->next = NULL;
}

//顶点元素v进队列
void EnQueue(Queue** Q, VertexType v) {
    Queue* temp = (*Q);
    //创建一个存储 v 的结点
    Queue* element = (Queue*)malloc(sizeof(Queue));
    element->data = v;
    element->next = NULL;
    //将 v 添加到队列链表的尾部
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = element;
}

//队头元素出队列
void DeQueue(Queue** Q, int* u) {
    Queue* del = (*Q)->next;
    (*u) = (*Q)->next->data;
    (*Q)->next = (*Q)->next->next;
    free(del);
}

//判断队列是否为空
bool QueueEmpty(Queue* Q) {
    if (Q->next == NULL) {
        return true;
    }
    return false;
}

//释放队列占用的堆空间
void DelQueue(Queue* Q) {
    Queue* del = NULL;
    while (Q->next) {
        del = Q->next;
        Q->next = Q->next->next;
        free(del);
    }
    free(Q);
}

//广度优先搜索
void BFSTraverse(MGraph G) {
    int v, u, w;
    Queue* Q = NULL;
    InitQueue(&Q);
    //将用做标记的visit数组初始化为false
    for (v = 0; v < G.vexnum; ++v) {
        visited[v] = false;
    }
    //遍历图中的各个顶点
    for (v = 0; v < G.vexnum; v++) {
        //若当前顶点尚未访问，从此顶点出发，找到并访问和它连通的所有顶点
        if (!visited[v]) {
            //访问顶点，并更新它的访问状态
            printf("%d ", G.vexs[v]);
            visited[v] = true;
            //将顶点入队
            EnQueue(&Q, G.vexs[v]);
            //遍历队列中的所有顶点
            while (!QueueEmpty(Q)) {
                //从队列中的一个顶点出发
                DeQueue(&Q, &u);
                //找到顶点对应的数组下标
                u = LocateVex(&G, u);
                //遍历紧邻 u 的所有顶点
                for (w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w)) {
                    //将紧邻 u 且尚未访问的顶点，访问后入队
                    if (!visited[w]) {
                        printf("%d ", G.vexs[w]);
                        visited[w] = true;
                        EnQueue(&Q, G.vexs[w]);
                    }
                }
            }
        }
    }
    DelQueue(Q);
}
int main() {
    MGraph G;
    //构建图
    CreateDN(&G);
    //对图进行广度优先搜索
    BFSTraverse(G);
    return 0;
}
```



### 树的深度

树中各个节点的深度是一种自顶向下的统计信息

起初，我们已知根节点深度是0 00.若节点x的深度为d [ x ] d[x]d[x],则它的子结点 y yy 的深度就是d [ y ] = d [ x ] + 1 

```c++
int dep[N];
void dfs(int u){
	vis[u] = 1;
	for(int i = head[u];i;i = nex[i]){
		int v = ver[i];
		if(vis[v])
			continue;
		dep[v] = dep[u]+1;//父结点 u 到子结点 v  递推 
		dfs(v);
	}
}
```



### 树的重心与size

树的重心是自底向上统计的
树的重心也叫树的质心。对于一棵树n个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。

```c++
int vis[N];
int Size[N];
int ans = INF;
int id;
void dfs(int u){
    vis[u] = 1;
    Size[u] = 1;//子树的大小
    int max_part = 0;
    for(int i = head[u];i;i = nex[i]){
        int v = ver[i];
        if(vis[v])
            continue;
        dfs(v);
        Size[u] += Size[v];
        max_part = max(max_part,Size[v]);//比较儿子的size因为这里是假设以u为重心
    }
    max_part = max(max_part,n-Size[u]);//n为整棵树的结点数
    if(max_part<ans){//更新
        ans = max_part;//记录重心对应的max_part的值
        id = u;//记录重心位置
    }
}
```



### 树的连通块划分

若在一个无向图中的一个子图中任意两个点之间都存在一条路径（可以相互到达），并且这个子图是“极大的”（不能在扩展），则称该子图是原图的一个联通块

如下代码所示，cnt是联通块的个数，v记录的是每一个点属于哪一个联通块
经过连通块划分，可以将森林划分出每一颗树，或者将图划分为各个连通块。

```c++
int cnt;
void dfs(int u){
    vis[u] = cnt;//这里存的是第几颗树或者是第几块连通图
    for(int i = head[u];i;i = nex[i]){
        int v = ver[i];
        if(vis[v])
            continue;
        dfs(v);
    }
}
int main()
{
    for(int i = 1;i<=n;++i){
        if(!vis[i])//如果是颗新树就往里面搜
            ++cnt,dfs(i);
    }
}
```



## DFS算法效率分析

用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O ( n 2 )

用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)。

结论：
稠密图适于在邻接矩阵上进行深度遍历；

稀疏图适于在邻接表上进行深度遍历。


## 树与图的广度优先遍历

```c++
void bfs(){
    memset(d,0,sizeof d);
    queue<int>q;
    q.push(1);
    d[1] = 1;
    while(q.size()){
        int u = q.front();
        q.pop();
        for(int i = head[u];i;i = nex[i]){
            int v = ver[i];
            if(d[v])continue;
            d[v] = d[u]+1;
            q.push(v);
        }
    }
}
```

广度优先遍历是一种按照层次顺序访问的方法。
它具有两个重要的性质：

1. 在访问完所有的第i层结点后，才会访问第i+1层结点。
2. 任意时刻，队列中只会有两个层次的结点，满足“两段性”和“单调性”。

## BFS算法效率分析

如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（ n 个元素），总的时间代价为O ( n 2 ) 

用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历，加上访问 n个头结点的时间，时间复杂度为O(n+e)

# 树的应用

## 最小生成树

**极小连通子图**：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。
**生成树**：包含图G所有顶点的极小连通子图（n-1条边）。

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228568439212.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228574723215.png)

首先明确：

1. 使用不同的遍历图的方法，可以得到不同的生成树
2. 从不同的顶点出发，也可能得到不同的生成树。
3. 按照生成树的定义，n 个顶点的连通网络的生成树有 n 个顶点、n-1 条边。

目标：
在网的多个生成树中，寻找一个**各边权值之和最小**的生成树。

Kruskal算法可以简单理解为按边贪心。
Prim算法是以更新过的节点的连边找最小值

**Prim算法适用于稠密图**
**Kruskal适用于稀疏图**

### Kruskal算法

每次选择权值最小的边，若该边两点没有加入集合，就将他加入。
起初每个点的都是一个独立的集合，把边权从小到达排序，按照边权枚举边，用并查集判断两个是否在同一个集合，如果在一个集合就跳过当前边，反之就联通这两个集合。

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<vector>

#define over(i,s,t) for(register int i = s;i <= t;++i)
#define lver(i,t,s) for(register int i = t;i >= s;--i)
//#define int __int128
#define lowbit(p) p&(-p)
using namespace std;

typedef long long ll;
typedef pair<int,int> PII;
const int N = 2e5+7;

struct node{
    int x,y,z;
    bool operator<(node &t)const{
        return z < t.z;
    }
}edge[N];

int fa[N],n,m,ans;

int Find(int x){
    if(x == fa[x])return x;
    return fa[x] = Find(fa[x]);
}

int main()
{
    cin>>n>>m;
    over(i,1,m)
    scanf("%d %d%d",&edge[i].x,&edge[i].y,&edge[i].z);
    sort(edge + 1,edge + 1 + m);
    over(i,1,n)
    fa[i] = i;
    over(i,1,m){
        int x = Find(edge[i].x);
        int y = Find(edge[i].y);
        if(x == y)continue;
        fa[x] = y;
        ans += edge[i].z;
    }
    printf("%d\n",ans);
}
```



### Prim算法

每次选择当前点所连的边的最小值，然后把它连起来

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<vector>
#include<queue>

#define over(i,s,t) for(register int i = s;i <= t;++i)
#define lver(i,t,s) for(register int i = t;i >= s;--i)
//#define int __int128
#define lowbit(p) p&(-p)
using namespace std;

typedef long long ll;
typedef pair<int,int> PII;
const int N = 4e5+7;

int ver[N],nex[N],edge[N],head[N],tot;
int n,m,ans;
int dis[N];
int vis[N],cnt;
void add(int u,int v,int val){
    ver[++tot] = v;
    edge[tot] = val;
    nex[tot] = head[u];
    head[u] = tot;
}

priority_queue<PII,vector<PII>,greater<PII> >q;

void prim(){
    dis[1] = 0;
    q.push({0,1});
    while(q.size()&&cnt != n){
        int d = q.top().first,u = q.top().second;
        q.pop();
        if(vis[u])continue;
        cnt++;
        ans += d;
        vis[u] = 1;
        for(int i = head[u];i;i = nex[i]){
            int v = ver[i];
            if(edge[i] < dis[v])
                dis[v] = edge[i],q.push({dis[v],v});
        }
    }
}

int main()
{
    memset(dis,0x3f,sizeof dis);
    scanf("%d%d",&n,&m);
    over(i,1,m){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    prim();
    printf("%d\n",ans);
    return 0;
}
```



## 最短路径算法

### Dijkstra算法

从起点开始，用一个dis数组存从起点到每一个点的最短距离，每次在当前点更新dis数组（可能经过当前点u到达的v点的总距离dis[u]+edge[v]是小于dis[v]就更新），然后往下走。
最后得到一个dis数组。

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228704876218.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228710683221.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228716576224.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228722667227.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228731044230.png)



```c++
#include<bits/stdc++.h>
using namespace std;
#define debug(x) cout<<"#  "<<x<<" "<<endl;
typedef long long ll;
const ll mod=2147483647000;
const ll N=500007;
struct Edge
{
    ll v,w,next;//v:目的地,w:距离,next:下一个节点
}G[N];
ll head[N],cnt,n,m,s;
ll dis[N];//存距离
inline void addedge(ll u,ll v,ll w)//链式前向星存图
{
    cnt++;
    G[cnt].w=w;
    G[cnt].v=v;
    G[cnt].next=head[u];
    head[u]=cnt;
}
struct node
{
    ll d,u;//d是距离u是起点
    bool operator<(const node& t)const//重载运算符
    {
        return d>t.d;
    }
};
inline void Dijkstra()
{
    for(register int i=1;i<=n;++i)dis[i]=mod;//初始化
    dis[s]=0;
    priority_queue<node>q;//堆优化
    q.push((node){0,s});//起点push进去
    while(!q.empty())
    {
        node tmp=q.top();q.pop();
        ll u=tmp.u,d=tmp.d;
        if(d!=dis[u])continue;//松弛操作剪枝
        for(register int i=head[u];i;i=G[i].next)//链式前向星
        {
            ll v=G[i].v,w=G[i].w;
            if(dis[u]+w<dis[v])//符合条件就更新
            {
                dis[v]=dis[u]+w;
                q.push((node){dis[v],v});//沿着边往下走
            }
        }
    }
}
int main()
{
    scanf("%lld %lld %lld",&n,&m,&s);
    for(register int i=1;i<=m;++i)
    {
        ll x,y,z;
        scanf("%lld %lld %lld",&x,&y,&z);
        addedge(x,y,z);//建图
    }
    Dijkstra();
    for(register int i=1;i<=n;++i)
        printf("%lld ",dis[i]);
    printf("\n");
    return 0;
}
```



## 拓扑排序



## 关键路径

这里每到达一个结点（事件）就必须要花所有指向该结点的边的权值最大（活动可以同时进行），即所有边（活动）都完成才能触发该事件。

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228786468233.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228793384236.png)

下面的公式:
事件的最早发生时间（ V e ( j ) ）
事件的最迟发生时间（ V l ( j ) ） 
活动的最早开始时间：e ( a i ) = V e ( j )
活动的最迟开始时间：l ( a i ) = V l ( k ) − d u t ( j , k ) 
![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228847738239.png)

实例：求事件结点的最早发生时间

```c++
Status  Topologicalsort（ ALGraph G,  Stack &T）
{  FindinDegree（G，indegree）;       // 对各顶点求入度，建立入度为零的栈 S，
Initstack（T）；count = 0;
    ve [ 0 .. G.vexnum - 1 ] = 0;
while （！StackEmpty（S））
       {  Pop（S，j）;Push（T，j）; ++count;
           for （p=G.vertices[i]. firstarc; p; p=p->nextarc）;
	{ k = p->adjnexr;
	   if （!（- - indegree [ k ]）） Push（S, k）;
	   if （ve[ j ]+ *（ p->info）> ve[  k ] ）
                               ve[ k ]  = ve[ j ] +  *（ p->info）; }
                     }
        }
     if （count < G.vexnum）return ERROR;
     else return OK;
} //  栈 T 为求事件的最迟发生时间的时候用。
```

实例：求事件结点的最迟发生时间

![在这里插入图片描述](%E5%9B%BE.assets/20200610103748572.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228894060244.png)

![在这里插入图片描述](%E5%9B%BE.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668228900183247.png)

