# 顺序查找

从查找表的一端开始，将表中的元素逐一和目标元素做比较，直至找到目标元素

```c
#include <stdio.h>
#include <stdlib.h>
#define keyType int
typedef struct {
    keyType key;//查找表中每个数据元素的值
    //如果需要，还可以添加其他属性
}ElemType;
//顺序表表示查找表
typedef struct {
    ElemType* elem; //存放查找表中数据元素的数组
    int length; //记录查找表中数据的总数量
}SSTable;
//创建查找表
void Create(SSTable* st, int length) {
    int i;
    st->elem = (ElemType*)malloc((length + 1) * sizeof(ElemType)); // +1 是为了给监视哨留出位置
    st->length = length;
    printf("输入表中的数据元素：\n");
    //根据查找表中数据元素的总长度，在存储时，从数组下标为 1 的空间开始存储数据
    for (i = 0; i < length; i++) {
        scanf("%d", &(st->elem[i].key));
    }
}
//查找表查找的功能函数，其中key为关键字
int Search_seq(SSTable st, keyType key) {
    int i;
    st.elem[st.length].key = key;//将目标元素存放在顺序表最后的位置，起监视哨的作用
    //从查找表第一个元素开始，直至找到目标元素
    for (i = 0; st.elem[i].key != key; i++);
    //如果 i=st.length，说明查找失败；反之，返回的是含有关键字key的数据元素在查找表中的位置
    return i;
}
int main() {
    int key, location, len;
    SSTable st;
    printf("输入查找表中的元素个数：");
    scanf("%d", &len);
    Create(&st, len);
    printf("请输入查找数据的关键字：");
    scanf("%d", &key);
    location = Search_seq(st, key);
    if (location == st.length) {
        printf("查找失败");
    }
    else {
        printf("目标元素在查找表中的位置为：%d", location + 1);
    }
    free(st.elem);
    return 0;
}
```

顺序查找的时间复杂度为`O(n)`

# 二分(折半)查找

## 实现思路

在升序的查找表 {10, 14, 19, 26, 27, 31, 33, 35, 42, 44} 中查找元素 33。初始状态下，搜索区域为整个查找表，用 low 记录搜索区域内第一个元素的位置，用 high 记录搜索区域内最后一个元素的位置

![img](%E6%9F%A5%E6%89%BE.assets/2-220H41546424X.gif)

二分查找算法的查找过程是：
1、借助 ⌊(low+high)/2⌋ 公式，找到搜索区域内的中间元素。图 1 中，搜索区域内中间元素的位置是 ⌊(1+10)/2⌋=5，因此中间元素是 27，此元素显然不是要找的目标元素

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154A5935.gif)

整个查找表为升序序列，根据 27<33，可以判定 33 位于 27 右侧的区域，更新搜索区域为元素 27 右侧的区域

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154FA30.gif)

2、搜索区域内中间元素的位置是 ⌊(6+10)/2⌋=8，因此中间元素是 35，此元素不是要找的目标元素

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154GB06.gif)

根据 35>33，可以判定 33 位于 35 左侧的区域，更新搜索区域

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154I5N4.gif)

3、搜索区域内中间元素的位置是 ⌊(6+7)/2⌋=6，因此中间元素是 31，此元素不是要找的目标元素

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154J5B2.gif)

根据 31<33，可以判定 33 位于 31 右侧的区域，更新搜索区域

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154KR63.gif)

搜索区域内中间元素的位置是 ⌊(7+7)/2⌋=7，因此中间元素是 33，此元素就是要找的目标元素

![img](%E6%9F%A5%E6%89%BE.assets/2-220H4154P9D1.gif)

## 代码实现

```c
#include <stdio.h>
#include <stdlib.h>
#define keyType int

typedef struct {
    keyType key; //查找表中每个数据元素的值
    //如果需要，还可以添加其他属性
}ElemType;

typedef struct {
    ElemType* elem; //存放查找表中数据元素的数组
    int length; //记录查找表中数据的总数量
}SSTable;

//创建查找表
void Create(SSTable* st, int length) {
    int i;
    st->length = length;
    st->elem = (ElemType*)malloc((length) * sizeof(ElemType));
    printf("输入表中的元素：\n");
    //根据查找表中数据元素的总长度，在存储时，从数组下标为 1 的空间开始存储数据
    for (i = 0; i < length; i++) {
        scanf("%d", &(st->elem[i].key));
    }
}

//折半查找算法
int Search_Bin(SSTable ST, keyType key) {
    int low = 0; // 初始状态 low 指针指向第一个关键字
    int high = ST.length - 1; // high 指向最后一个关键字
    int mid;
    while (low <= high) {
        mid = (low + high) / 2; // int 本身为整形，所以 mid 每次为取整的整数
        if (ST.elem[mid].key == key) // 如果 mid 指向的同要查找的相等，返回 mid 所指向的位置
        {
            return mid;
        }
        else if (ST.elem[mid].key > key) // 如果mid指向的关键字较大，则更新 high 指针的位置
        {
            high = mid - 1;
        }
        // 反之，则更新 low 指针的位置
        else {
            low = mid + 1;
        }
    }
    //未在查找表中找到目标元素，查找失败
    return -1;
}

int main() {
    int len, key;
    int location;
    SSTable st = { 0 };
    printf("请输入查找表的长度：");
    scanf("%d", &len);
    Create(&st, len);
    printf("请输入查找数据的关键字：");
    scanf("%d", &key);
    location = Search_Bin(st, key);
    //如果返回值为 -1，证明查找表中未查到 key 值，
    if (location == -1) {
        printf("查找表中无目标元素");
    }
    else {
        printf("目标元素在查找表中的位置为：%d", location + 1);
    }
    free(st.elem);
    return 0;
}
```

二分查找的时间复杂度为O($log_2n$)



# 分块查找

例如，下图所示为一个表及索引表，表中有18个记录，可分为3个子表（R1,R2,.....R6）,（R7,R8.....R12）,(R13,R14......R18)，对每个子表建立一个索引项，其中包括两项内容：关键字（其值为该子表中的最大关键字）和指针项（指示该子表的第一个记录在表中的位置）。索引表按关键字有序，则表或者有序或者分块有序。所谓“分块有序”指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，......,以此类推
![image-20221202213140143](%E6%9F%A5%E6%89%BE.assets/image-20221202213140143.png)

分块查找的步骤为：**先确定待查记录所在的子块，然后在块中顺序查找**。由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找。而块中记录是任意排序的，则在块中只能是顺序查找

```c
#include <stdio.h>
#include <stdlib.h>
struct index{//定义索引表 
	int key;//最大关键字 
	int start;//起始地址 
}newIndex[3]; //定义结构体数组
 int cmp(const void*a,const void*b){
 	return (*(struct index*)a).key>(*(struct index*)b).key?1:-1;
 } 
 int search(int key,int a[])
 {
 	int i=0,startvalue;
	 while(i<3&&newIndex[i].key <key)
	 {
	 	i++; 
	 }
	 if(i>3)
	 {
	 	return -1;
	 }
	 startvalue=newIndex[i].start ;
	 while(startvalue<=startvalue+5&&a[startvalue]!=key)
	 {
	 	startvalue++;
	 }
	 if(startvalue>startvalue+5)
	 {
	 	return -1;
	 }
	 return startvalue;
 	
  } 
  int main()
  {
  int i,j=1,k,key,n;
  int a[20];
  printf("要输入数据的个数为：\n");
  scanf("%d",&n);
  printf("请输入(数量为3的整数倍的)数据：\n");
  for(i=0;i<n;i++)
  {
  	scanf("%d",&a[i]);
  }
  //确定模块的起始值和最大值 
  for(i=0;i<3;i++)
  {
  	newIndex[i].start =j;
	  j+=6;
	  for(int k=newIndex[i].start;k<=j;k++)
	  {
	  	if(newIndex[i].key<a[k])
	  	{
	  		newIndex[i].key=a[k];
		  }
	   } 
	}  
 //对结构体按照key值进行排序
 qsort(newIndex,3,sizeof(newIndex[0]),cmp);
 
 //输入要查询的数，并调用函数进行查找 
 printf("输入您想要查找的数：\n");
 scanf("%d",&key);
 k=search(key,a);
 //输出查找结果
 if(k>0)
 {
 	printf("查找成功！您要找的数在数组中的位置是:%d\n",k+1);
  } 
  else{
  	printf("查找失败！您查找的数不在数组中。\n");
  }
  return 0;
}
```



# 二叉排序树



# 平衡二叉树



# 红黑树



# B-树



# B+树



# 哈希表



# 哈希查找