# 线性表顺序存储结构（顺序表）

![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70.png)

**线性表的定义**：

- 存在唯一一个“第一个”元素
- 存在唯一一个“最后一个”元素
- 除第一个元素外，每一个元素都有且只有一个前驱
- 除最后一个元素外，每个元素都有且只有一个后继

## 线性表的基本概念

线性表强调元素在逻辑上紧密相邻，所以首先想到用数组存储。但是普通数组有着无法克服的容量限制，在不知道输入有多少的情况下，很难确定出一个合适的容量。对此，一个较好的解决方案就是使用动态数组。首先用malloc申请一块拥有指定初始容量的内存，这块内存用作存储线性表元素，当录入的内容不断增加，以至于超出了初始容量时，就用malloc扩展内存容量，这样就做到了既不浪费内存，又可以让线性表容量随输入的增加而自适应大小。

线性表顺序存储结构如下图： 
![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-16682218395563.png)



**优点：**

- 存储密度大（结点本身所占存储量/结点结构所占存 储量）
- 可以随机存取表中任一元素

**缺点：**

- 在插入、删除某一元素时，需要移动大量元素
- 浪费存储空间
- 属于静态存储形式，数据元素的个数不能自由扩充

# 线性表链式存储结构（链表）

## 链表的基本概念

**建议每次写的时候都加一个头节点**

**各结点由两个域组成：**
**数据域：**存储元素数值数据
**指针域：**存储直接后继结点的存储位置

- 结点：数据元素的存储映像。 由数据域和指针域两部分组成
- 链表： n 个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构

**单链表、双链表、循环链表：**

结点只有一个指针域的链表，称为单链表或线性链表
有两个指针域的链表，称为双链表
首尾相接的链表称为循环链表

![img](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/1RG36342-4.gif)

**头指针**是指向链表中第一个结点的指针

**首元结点**是指链表中存储第一个数据元素a1的结点

**头结点**是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息

Q：1.如何表示空表？
有头结点时，当头结点的指针域为空时表示空表
Q：2. 在链表中设置头结点有什么好处

- 便于首元结点的处理 首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;

- 便于空表和非空表的统一处理

无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。

头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。

**结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻**

![img](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/1RG32210-3.gif)

这种存取元素的方法被称为顺序存取法

可以用结构体表示链表中的结点

```c
typedef struct link{
    char elem; //代表数据域
    struct link * next; //代表指针域，指向直接后继元素
}Link;
```

**优点**

- 数据元素的个数可以自由扩充
- 插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高

**缺点**

- 存储密度小
- 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问

## 创建链表

创建一个存储 {1,2,3,4} 且无头节点的链表

```c
Link* initLink() {
    int i;
    //1、创建头指针
    Link* p = NULL;
    //2、创建首元结点
    Link* temp = (Link*)malloc(sizeof(Link));
    temp->elem = 1;
    temp->next = NULL;
    //头指针指向首元结点
    p = temp;
    //3、每创建一个结点，都令其直接前驱结点的指针指向它
    for (i = 2; i < 5; i++) {
        //创建一个结点
        Link* a = (Link*)malloc(sizeof(Link));
        a->elem = i;
        a->next = NULL;
        //每次 temp 指向的结点就是 a 的直接前驱结点
        temp->next = a;
        //temp指向下一个结点（也就是a),为下次添加结点做准备
        temp = temp->next;
    }
    return p;
}
```

创建一个存储 {1,2,3,4} 且含头节点的链表

```c
Link* initLink() {
    int i;
    //1、创建头指针
    Link* p = NULL;
    //2、创建头结点
    Link* temp = (Link*)malloc(sizeof(Link));
    temp->elem = 0;
    temp->next = NULL;
    //头指针指向头结点
    p = temp;
    //3、每创建一个结点，都令其直接前驱结点的指针指向它
    for (i = 1; i < 5; i++) {
        //创建一个结点
        Link* a = (Link*)malloc(sizeof(Link));
        a->elem = i;
        a->next = NULL;
        //每次 temp 指向的结点就是 a 的直接前驱结点
        temp->next = a;
        //temp指向下一个结点（也就是a),为下次添加结点做准备
        temp = temp->next;
    }
    return p;
}
```

## 前插法代码实例

因为是前插法，所以是倒着顺序插入的（先入后出，先插入的在后面）

```c++
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#define over(i,s,t) for(register int i=s;i<=t;++i)
#define lver(i,t,s) for(register int i=t;i>=s;--i)
typedef long long ll;
//#define int __int128
typedef struct item
{
    //double coef;
    int expn;
}ElemType;

typedef struct Lnode//将struct Lnode命名为LNode
{
    ElemType data;        //数据域
    struct Lnode *next;   //指针域 是Lnode！
}LNode,*LinkList;//LNode类型的指针LinkList

//单链表的建立（前插法）
void InsertList(LNode *it,int val)//前插法//int index
{
    LNode *tmp;
    tmp=(LNode *)malloc(sizeof (LNode));
    tmp->data.expn=val;
    tmp->next=it->next;
    it->next=tmp;
}

//删除一个节点
void deletenode(LNode *it,int val)
{
    LNode *tmp=it->next,*last=it;
    while(tmp->data.expn!=val&&tmp->next!=NULL){

        tmp=tmp->next;
        last=last->next;
    }
    if(tmp==NULL){//没有数据域为a的结点
        //puts("没有，滚");
        puts("Not found");
    }
    else {
        last->next=tmp->next;
    }
    free(tmp);
}

//单链表的建立（尾插法）
int n,a[10000];

int main()
{
    scanf("%d",&n);
    over(i,1,n)
        scanf("%d",&a[i]);
    LNode *head;
    head=(LNode*)malloc(sizeof (LNode));
    head->next=NULL;
    lver(i,n,1){
        InsertList(head,a[i]);
    }
    deletenode(head,1);
    LNode *p;
    p=head->next;
    while(p!=NULL){
        printf("%d ",p->data.expn);
        p=p->next;
    }
    return 0;
}
```



## 链表尾插法代码

```c++
#include<stdio.h>
#include<malloc.h>
#include<string.h>

typedef struct student{
    int score;//数据域；
    struct student *next;//指针域；
}Linklist;

Linklist *creat(int n)//创建链表
{
    Linklist *head,*node,*end;
    head=(Linklist*)malloc(sizeof(Linklist));
    end=head;
    for(int i=0;i<n;i++)
    {
        node=(Linklist*)malloc(sizeof(Linklist));
        scanf("%d",&node->score);
        end->next=node;
        end=node;
    }
    end->next=NULL;
    return head;
}
void change(Linklist*list,int n)//修改链表
//n是要修改的第n个节点，因为链表只能顺序访问不能随机访问，不好用，学这个用来入门数据结构
{
    Linklist*t=list;
    int i=0;
    while(i<n&&t!=NULL)//往后移去找第N个节点
    {
        t=t->next;
        i++;
    }
    if(t!=NULL)
    {
        puts("快点地，输入要修改的值");
        scanf("%d",&t->score);
        printf("修改成功\n");
    }
    else puts("节点不存在哟");
}
void delet(Linklist*list,int n)//删除链表中的值
{
    Linklist *t=list,*in;
    int i=0;
    while(i<n&&t!=NULL)
    {
        in=t;//in指向的一直是现在t所指向的上一个（先让in指向t，再让t指向下一个）
        t=t->next;
        i++;
    }
    if(t!=NULL)
    {
        in->next=t->next;//要删除t，让指向它的指针指向下一个，跳过t就是删除了t；
        free(t);//清除t的内存；
    }
    else puts("节点不存在！请以后再来探索吧");
}
void insert (Linklist*list,int n)//插入链表    （在第n位之后插入值（插完之后是第n+1位））
{
    Linklist*t=list,*in;
    int i=0;
    while(i<n&&t!=NULL)
    {
        t=t->next;//先找到要插入的位置
        i++;
    }
    if(t!=NULL)
    {
        in=(Linklist*)malloc(sizeof(Linklist));
        puts("请输入要插入的值：");
        scanf("%d",&in->score);
        in->next=t->next;
        t->next=in;
        puts("插进去了呢");
    }
    else puts("节点不存在，你别玩我呀");
}
void coutlist(Linklist*head)//输出链表的值；
{
    while(head->next!=NULL)
    {
        head=head->next;
        printf("%d ",head->score);
    }
    printf("\n");
}
void coutlength(Linklist*list)//输出链表的长度（带头结点）
{
    Linklist*t=list;//非空表的情况下指向的是第一个结点而不是头结点
    int ans=0;
    while(t->next)
    {
        t=t->next;
        ans++;
    }
    printf("%d\n",ans);
}
void find(Linklist*lists,int x)//按值查找w
{
    Linklist* t=lists->next;
    while(t!=NULL&&t->score!=x)
        t=t->next;
    if(t!=NULL)printf("太棒了，找到了呢\n");
    return ;
}
void list()//控制面板
{
    printf("这是一个单链表\n------------------------------------------\nPlease press the button:\n");
    printf("Button 1 ---> 创建单链表\n");				//创建单链表 (带头结点、表尾插入)
    printf("Button 2 ---> 获取链表长度\n");				//获取链表长度
    printf("Button 3 ---> 插入结点\n");				//按序号查找
    printf("Button 4 ---> 按值查找\n");				//按值查找
    printf("Button 5 ---> 删除结点\n");		//插入结点
    printf("Button 6 ---> 修改节点\n");				//删除结点
    printf("Button 7 ---> 输出链表的值\n");							//遍历链表
    printf("Button 8 ---> Exit the program\n-----------------------------------\n");					//退出程序
}

int main()
{
    list();
    Linklist*h;
    int n,x,m;
    while(true)
    {
        scanf("%d",&n);
        if(n==1)
        {
            printf("请输入一个数字，创建长度为n的链表:\n请输入要加入链表的数：");
            scanf("%d",&x);
            h=creat(x);
            printf("Please press the button:\n");
        }
        if(n==2)
        {
            printf("单链表的长度是:");
            coutlength(h);
            printf("Please press the button:\n");
        }
        if(n==3)
        {
            printf("你想插到哪儿？(手动滑稽)");
            scanf("%d",&x);
            insert (h,x);
            printf("Please press the button:\n");
        }
        if(n==4)
        {
            printf("请输入你要找的值");
            scanf("%d",&m);
            find(h,m);
            printf("Please press the button:\n");
        }
        if(n==5)
        {
            printf("你敢删谁？有种你试试！\n");
            scanf("%d",&x);
            delet(h,x);
            printf("还真敢呐，太顶了！\n");
            printf("Please press the button:\n");
        }
        if(n==6)
        {
            printf("你要改那个值？");
            scanf("%d",&x);
            change(h,x);
            printf("Please press the button:\n");
        }
        if(n==7)
        {
            coutlist(h);
            printf("Please press the button:\n");
        }
        if(n==8)
        {
            printf("拜拜了您呐\n");
            return 0;
        }
    }
    return 0;
}
```

## 链表的基本操作

```c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct link {
    int  elem;
    struct link* next;
}Link;
Link* initLink() {
    int i;
    //1、创建头指针
    Link* p = NULL;
    //2、创建头结点
    Link* temp = (Link*)malloc(sizeof(Link));
    temp->elem = 0;
    temp->next = NULL;
    //头指针指向头结点
    p = temp;
    //3、每创建一个结点，都令其直接前驱结点的指针指向它
    for (i = 1; i < 5; i++) {
        //创建一个结点
        Link* a = (Link*)malloc(sizeof(Link));
        a->elem = i;
        a->next = NULL;
        //每次 temp 指向的结点就是 a 的直接前驱结点
        temp->next = a;
        //temp指向下一个结点（也就是a),为下次添加结点做准备
        temp = temp->next;
    }
    return p;
}
//p为链表，elem为目标元素，add为要插入的位置
void insertElem(Link* p, int elem, int add) {
    int i;
    Link* c = NULL;
    Link* temp = p;//创建临时结点temp
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("插入位置无效\n");
            return;
        }
    }
    //创建插入结点c
    c = (Link*)malloc(sizeof(Link));
    c->elem = elem;
    //① 将新结点的 next 指针指向插入位置后的结点
    c->next = temp->next;
    //② 将插入位置前结点的 next 指针指向插入结点；
    temp->next = c;
}
//p为原链表，elem 为要删除的目标元素
int delElem(Link* p, int elem) {
    Link* del = NULL, *temp = p;
    int find = 0;
    //1、找到目标元素的直接前驱结点
    while (temp->next) {
        if (temp->next->elem == elem) {
            find = 1;
            break;
        }
        temp = temp->next;
    }
    if (find == 0) {
        return -1;//删除失败
    }
    else
    {
        //标记要删除的结点
        del = temp->next;
        //2、将目标结点从链表上摘除
        temp->next = temp->next->next;
        //3、释放目标结点
        free(del);
        return 1;
    }
}
//p为原链表，elem表示被查找元素
int selectElem(Link* p, int elem) {
    int i = 1;
    //带头结点，p 指向首元结点
    p = p->next;
    while (p) {
        if (p->elem == elem) {
            return i;
        }
        p = p->next;
        i++;
    }
    return -1;//返回-1，表示未找到
}
//p 为有头结点的链表，oldElem 为旧元素，newElem 为新元素
int amendElem(Link* p, int oldElem, int newElem) {
    p = p->next;
    while (p) {
        if (p->elem == oldElem) {
            p->elem = newElem;
            return 1;
        }
        p = p->next;
    }
    return -1;
}
//输出链表中各个结点的元素
void display(Link* p) {
    p = p->next;
    while (p) {
        printf("%d ", p->elem);
        p = p->next;
    }
    printf("\n");
}
//释放链表
void Link_free(Link* p) {
    Link* fr = NULL;
    while (p->next)
    {
        fr = p->next;
        p->next = p->next->next;
        free(fr);
    }
    free(p);
}
int main() {
    Link* p = initLink();
    printf("初始化链表为：\n");
    display(p);
    printf("在第 3 的位置上添加元素 6：\n");
    insertElem(p, 6, 3);
    display(p);
    printf("删除元素4：\n");
    delElem(p, 4);
    display(p);
    printf("查找元素 2：\n");
    printf("元素 2 的位置为：%d\n", selectElem(p, 2));
    printf("更改元素 1 的值为 6：\n");
    amendElem(p, 1, 6);
    display(p);
    Link_free(p);
    return 0;
}
```



# 双向链表

## 双向链表的基本概念

双链表顾名思义，就是链表由单向的链变成了双向链。 使用这种数据结构，我们可以不再拘束于单链表的单向创建于遍历等操作，大大减少了在使用中存在的问题。每一个节点都有两个指针分别指向该节点的前驱和后继。

定义：

```c++
struct DuLNode{
    EtypedeflemType   data; //数据域          
    struct DuLNode  *prior; //前驱 
    struct DuLNode  *next;  //后继
}DuLNode, *DuLinkList
```

![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/20200429100627547.png)

```c++
d->next->prior = d->prior->next = d
```



## 双向链表的插入

![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-16682222354308.png)

由于每个节点都有前驱和后继，所以插入的时候p节点及其前驱的前驱和后继都要更新。所以需要按顺序写四条语句更新。（新增结点别忘了给数据域赋值）

```c++
s->prior=p->prior;
p->prior->next=s;
s->next=p;
p->prior=s;
```



## 双向链表的删除

![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822227359411.png)

删除一个结点，只需要把p结点的前驱的后继更新，p的后继的前驱更新，只需要两条语句即可。

```c++
p->prior->next=p->next;
p->next->prior=p->prior;
```

顺便别忘了`free(p);`



# 顺序表和链表的比较

![在这里插入图片描述](%E7%BA%BF%E6%80%A7%E8%A1%A8.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822230807514.png)



# 线性表的应用

## 有序表的合并

已知线性表La 和Lb中的数据元素按值非递减有序排列,现要求将La和Lb归并为一个新的线性表Lc,且Lc中的数据元素仍按值非递减有序排列。

```c++
La=(1 ,7, 8)
Lb=(2, 4, 6, 8, 10, 11)
Lc=(1, 2, 4, 6, 7 , 8, 8, 10, 11) 
```



### 新建一个链表

新建一个空表C，直接在A和B中每次选取最小值插入到C中，复杂度O(A.length+B.length)，但是需要新开辟一个空表比较占用内存。

```c++
void MergeList_Sq(SqList LA,SqList LB,SqList &LC){ 
    pa = LA.elem;  
    pb = LB.elem;     //指针pa和pb的初值分别指向两个表的第一个元素 
    LC.length = LA.length+LB.length;      	//新表长度为待合并两表的长度之和 
    LC.elem = new ElemType[LC.length];    	//为合并后的新表分配一个数组空间 
    pc = LC.elem;                         		//指针pc指向新表的第一个元素 
    pa_last = LA.elem+LA.length-1; 	//指针pa_last指向LA表的最后一个元素 
    pb_last = LB.elem+LB.length-1; 	//指针pb_last指向LB表的最后一个元素 
    while(pa <= pa_last && pb <= pb_last){  	//两个表都非空 
        if(*pa <= *pb) *pc++ = *pa++;        	//依次“摘取”两表中值较小的结点      
        else *pc++ = *pb++;   
    } 
    //此时a,b 之中一定有一个表为空
    while(pb <= pb_last)  *pc++ = *pb++;          //LB表已到达表尾
    while(pa <= pa_last)  *pc++ = *pa++;          //LA表已到达表尾 
}//MergeList_Sq 
```



### 直接合并

只建一个新结点，相当于尾插法的end尾结点，而不是创建一个新链表，结点Pc每次指向A/B中最小值的结点，把两个链表连在一起（B连到A上面），不需要新开辟一个链表浪费空间，时间复杂度和上面的一样，都是暴力循环。

```c++
void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){
   pa=La->next;  pb=Lb->next;
   pc=Lc=La;                    //用La的头结点作为Lc的头结点 
   while(pa && pb){
      if(pa->data<=pb->data){ pc->next=pa;pc=pa;pa=pa->next;}
      else{pc->next=pb; pc=pb; pb=pb->next;}
   pc->next=pa?pa:pb;      //插入剩余段  
   delete Lb;                     //释放Lb的头结点}  

```



# 小结

1. 掌握线性表的逻辑结构特性是数据元素之间存在着线性关系，在计算机中表示这种关系的两类不同的存储结构是顺序存储结构（顺序表）和链式存储结构（链表）。
2. 熟练掌握这两类存储结构的描述方法，掌握链表中的头结点、头指针和首元结点的区别及循环链表、双向链表的特点等。
3. 熟练掌握顺序表的查找、插入和删除算法
4. 熟练掌握链表的查找、插入和删除算法
5. 能够从时间和空间复杂度的角度比较两种存储结构的不同特点及其适用场合

