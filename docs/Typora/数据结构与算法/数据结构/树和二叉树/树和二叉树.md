![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70.png)

# 树

树：是N(N≥0)个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：  

- 有且仅有一个特定的称为根的结点。
- 当N>1时，其余结点可分为m(m>0)个互不相交的有限集合T1,T2,…,Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822351100867.png)

显然树的定义是递归的，是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：

1. 树的根结点没有前驱结点，除根结点之外的所有结点有且仅有一个前驱结点。
2. 树中所有结点可以有零个或者多个后继结点。

**树适合于表示具有层次结构的数据**
树中的某个结点（除了根结点之外）最多之和上一层的一个结点（其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中最多只有`n-1`条边。而树中每个结点与其下一层的零个或者多个结点（即其子女结点）有直接关系。

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822358789570.png)

对K来说：根结点A到K的唯一路径上的任意结点，称为K的**祖先结点**。如结点B是K的祖先节点，K是B的子孙结点。路径上最接近K的结点E称为K的**双亲结点**，K是E的**孩子结点**。根A是树中唯一没有双亲的结点。有相同双亲的结点称为**兄弟节点**，如K和L有相同的双亲结点E，即K和L是兄弟结点。
树中一个结点的子结点个数称为该结点的**度**，树中结点最大度数称为树的度。如B的度为2，但是D的度为3，所以该树的度为3.
度大于0的结点称为**分支结点**（又称为非终端结点）；度为0（没有子女结点）的结点称为**叶子结点**（又称终端结点）。在分支结点中，每个结点的分支数就是该节点的度。

**结点的高度，深度和层次。**

结点的层次从树根开始定义，根节点为第一层（有些教材将根节点定义为第0层），它的子结点为第2层，以此类推。
**结点的深度**是从根节点开始自顶向下逐层累加的。
**结点的高度**是从叶节点开始自底向上逐层累加的。

**树的高度**

（又称深度）是树中结点的最大层数。

## 有序树和无序树

树中结点的子树从左到右是有次序的，不能交换，这样的树称为**有序树**。有序树中，一个结点其子结点从左到右顺序出现是有关联的。反之称为无序树。在上图中，如果将子结点的位置互换，则变为一棵不同的树。
路径和路径长度：树中两个结点之间的路径是由这两个节点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。A和K的路径长度为3.路径为B，E。

## 森林

森林是m棵互不相交的树的集合。森林的概念和树的概念十分相近，因为只要把树的根节点删掉之后就变成了森林。反之，只要给n棵独立的树加上一个结点，并且把这n棵树作为该结点的子树，那么森林就变成了树。

## 树的基本性质

- 树中结点数等于所有节点的度数+1.
- 度为m的树中第i层上至多有mi−1个结点(i≥1)
- 高度为h的m叉树至多有mh−1m−1个结点。
- 具有n个结点的m叉树的最小高度为logm(n(m−1)+1)。

# 二叉树

- 性质1: 在二叉树的第 i 层上至多有2i−1个结点 
- 性质2: 深度为k的二叉树至多有$2^k-1$个结点
- 性质3: 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数n0必定为n2＋1 （即n0=n2+1）

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822377983173.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822378629776.png)

一棵完全二叉树有5000个结点，可以计算出其叶结点的个数是**2500**

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822381703379.png)

性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2。

## 二叉树的顺序存储

**实现**：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。

**特点**：
结点间关系蕴含在其存储位置中
浪费空间，适于存满二叉树和完全二叉树

## 二叉树的链式存储

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822396698082.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822398307885.png)



## 三叉树

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822399102888.png)



# 二叉树的遍历

**遍历定义**

指按某条搜索路线遍访每个结点且不重复（又称周游）。

**遍历用途**

它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。

**先(前)序遍历:** 对访问到的每个结点,先访问根结点,然后是左结点,然后是右结点。

**中序遍历:** 对访问到的每个结点,先访问左结点,然后是根结点,然后是右结点。

**后序遍历:** 对访问到的每个结点,先访问左结点,然后是右结点,然后是根结点。

例如：
![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822404051591.png)

先序遍历

```
1  2  4  5  7  8  3  6 
```

中序遍历

```
4  2  7  5  8  1  3  6
```

后序遍历

```
4  7  8  5  2  6  3  1
```

层次遍历

```
1  2  3  4  5  6  7  8
```

## 先序遍历

### 递归写法

```c++
void PreOrder(BitTree T)
{
    if(T!=NULL)
    {
        cout<<T->val<<"  ";
        PreOrder(T->l);
        PreOrder(T->r);
    }
}
```

### 非递归写法

根据先序遍历的顺序，先访问根结点，然后再访问左子树和右子树。所以，对于任意结点BitTree，第一部分即直接访问根节点，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。利用栈的先进后出，每次访问左子树时都把整个节点放到栈里面，左子树访问完了就往上走，判断父节点是否有右子树，有就访问，没有或者访问完毕就继续往上找父节点，直到将树按先序遍历方式全部遍历完毕。

```c++
void PreOrder (BitTree T)
{
　　stack<BitTree>s;
　　BitTree p = T;
　　while(p || !s.empty)
　　{
　　　　if(p)
　　　　{
　　　　　　cout<<p->val<<"  ";
　　　　　　s.push(p);
　　　　　　p = p->l;
　　　　}else
　　　　{
　　　　　　p = s.top();
　　　　　　p = p->r;
　　　　　　p = p.pop();
　　　　}
　　}
}
```

中序遍历和后序遍历的非递归方法和先序遍历一样，改一下先后顺序即可

## 中序遍历

```c++
void InOrder(BitTree T)
{
    if(T!=NULL)
    {
        InOrder(T->l);
        printf("%d\n",T->val);
        InOrder(T->r)
    }
}
```



## 后序遍历

后序遍历的性质：对于一颗树，最后的那一个结点是**根节点**

递归遍历

```c++
void PostOrder(BitTree T)
{
    if(T!=NULL)
    {
        PostOrder(T->l);
        PostOrder(T->r);
        printf("%d\n",T->val);
    }
}
```

非递归遍历

```c
#include <stdio.h>
#include <stdlib.h>
#define TElemType int
int top = -1;//表示栈顶
typedef struct BiTNode {
    TElemType data;//数据域
    struct BiTNode* lchild, * rchild;//左右孩子指针
}BiTNode, * BiTree;
//后序遍历非递归算法
typedef struct SNode {
    BiTree p;
    int tag;
}SNode;
void CreateBiTree(BiTree* T) {
    int num;
    scanf("%d", &num);
    //如果输入的值为 0，表示无此结点
    if (num == 0) {
        *T = NULL;
    }
    else
    {
        //创建新结点
        *T = (BiTree)malloc(sizeof(BiTNode));
        (*T)->data = num;
        CreateBiTree(&((*T)->lchild));//创建该结点的左孩子
        CreateBiTree(&((*T)->rchild));//创建该结点的右孩子
    }
}
//弹栈函数
void pop() {
    if (top == -1) {
        return;
    }
    top--;
}
//入栈
void push(SNode* a, SNode sdata) {
    a[++top] = sdata;
}
//后序遍历二叉树
void PostOrderTraverse(BiTree Tree) {
    SNode a[20];//定义一个顺序栈
    BiTNode* p = NULL;//临时指针
    int tag; //记录结点的标记位
    SNode sdata;
    p = Tree;
    while (p || (top != -1)) {
        while (p) {
            //为该结点入栈做准备
            sdata.p = p;
            sdata.tag = 0;//由于遍历是左孩子，设置标志位为0
            push(a, sdata);//压栈
            p = p->lchild;//以该结点为根结点，遍历左孩子
        }
        sdata = a[top];//取栈顶元素
        pop();//栈顶元素弹栈
        p = sdata.p;
        tag = sdata.tag;
        //如果tag==0，说明该结点还没有遍历它的右孩子
        if (tag == 0) {
            sdata.p = p;
            sdata.tag = 1;
            push(a, sdata);//更改该结点的标志位，重新压栈
            p = p->rchild;//以该结点的右孩子为根结点，重复循环
        }
        //如果取出来的栈顶元素的tag==1，说明此结点左右子树都遍历完了，可以访问该结点了
        else {
            printf("%d ", p->data);
            p = NULL;
        }
    }
}
//后序遍历二叉树，释放树占用的内存
void DestroyBiTree(BiTree T) {
    if (T) {
        DestroyBiTree(T->lchild);//销毁左孩子
        DestroyBiTree(T->rchild);//销毁右孩子
        free(T);//释放结点占用的内存
    }
}
int main() {
    BiTree Tree;
    CreateBiTree(&Tree);
    PostOrderTraverse(Tree);
    DestroyBiTree(Tree);
    return 0;
}
```



## 层序遍历

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822430626794.png)

这棵二叉树的层序遍历次序为：A、B、C、D、F、G
每次出队一个元素，就将该元素的子节点加入队列中，直至队列中元素个数为0时，出队的顺序就是该二叉树的层次遍历结果

```c++
void LevelOrder(BitTree T)
{
    queue<int>q;
    if (T == NULL){return;}
    q.push(T);
    while (!q.empty())
    {
        BitTree p=q.front();
        cout<<p.val;
        q.pop();
        if(p.l)
            q.push(p.l);
        if(p.r)
            q.push(p.r);
    }
}
```

以上四种种遍历算法中递归遍历左子树和右子树的顺序都是固定的，只是访问根节点的顺序不同。不管采用何种遍历方法，每个结点都是访问一次，所以时间复杂度就是`O(n)`。

在递归遍历中，递归工作栈的深度恰巧是树的深度，所以在最坏的情况下，二叉树是有n个结点且深度为n的单支树，递归遍历算法的时间复杂度是`O(n)`。

# 二叉树遍历算法的应用

## 二叉树的建立

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822438640197.png)

```c++
void CreateBiTree(BiTree &T）{
	cin>>ch;
	if (ch=='#')   
		T=NULL;  	//递归结束，建空树
	else {
	    T=new BiTNode;    
	    T->data=ch; 	//生成根结点
	    CreateBiTree(T->lchild);  //递归创建左子树
 	    CreateBiTree(T->rchild); //递归创建右子树
  }									
}										
```

## 计算二叉树结点总数

如果是空树，则结点个数为0；
否则，结点个数为左子树的结点个数+右子树的结点个数再+1。

```c++
int NodeCount(BiTree T){
	if(T == NULL ) return 0;  			    
	else return NodeCount(T->lchild)+NodeCount(T->rchild)+1;
} 
```

## 计算二叉树叶子结点总数

> 如果是空树，则叶子结点个数为0； 否则，为左子树的叶子结点个数+右子树的叶子结点个数

```c++
int LeadCount(BiTree T){
 	if(T==NULL) 	//如果是空树返回0
		return 0;
	if (T->lchild == NULL && T->rchild == NULL)
		return 1; //如果是叶子结点返回1
	else return LeafCount(T->lchild) + LeafCount(T->rchild);
}
```

## 计算二叉树深度

- 如果是空树，则深度为0；
- 否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。

```c++
int get_deep(tree *p){
    if(p == NULL)
        return 0;
    return max(deep(p->l),deep(p->r))+1;
}
```

## 重要结论

> 若二叉树中各结点的值均不相同，则： 由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，
> 但由前序序列和后序序列却不一定能唯一地确定一棵二叉树。

由中序遍历可以知道左右子树的结点个数。

## 由中序遍历和后序遍历建树

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224653213100.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224666031103.png)

# 森林

左指针指的是左孩子，右指针指的是兄弟，这样就避免了一颗多叉树需要像二叉树一样的每一个结点使用多个指针的情况了。

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224683495106.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224689853109.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224695313112.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224699666115.png)

# 哈夫曼树

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224762640118.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224769527121.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224782788124.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224796552127.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224801749130.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224807332133.png)

**哈夫曼树不唯一**



![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224832573136.png)

![在这里插入图片描述](%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-1668224838104139.png)