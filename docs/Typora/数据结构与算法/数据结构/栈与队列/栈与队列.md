![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70.png)

# 栈

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822254525019.png)

## 栈的基本定义

- 定义
    只能在表的一端（栈顶）进行插入和删除运算的线性表
- 逻辑结构
    与线性表相同，仍为一对一关系
- 存储结构
- 用顺序栈或链栈存储均可，但以顺序栈更常见
- 运算规则
    只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则
- 实现方式
    关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等

## 栈的实现

可以用一个数组和一个变量（记录栈顶位置）来实现栈结构

## 栈与递归

- **优点**：结构清晰，程序易读
- **缺点**：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。

设有一个递归算法如下:

```c++
int X(int n)
{
    if(n<=3) 
        return 1;
    else 
        return X(n-2)+X(n-4)+1;
}
```

则计算X(X(8))时需要计算X函数 多少次
A. 8 B.9 C.16 D.18

答案：D

## Hanoi塔问题

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+7;
const ll mod=1e9+7;
ll cnt,n;
void move(ll id,char from,char to)
{
    printf ("step %lld: move %lld from %c->%c\n", ++cnt, id, from, to);
}
void hanoi(ll n,char x,char y,char z)
{
    if(n==0)
        return;
    hanoi(n-1,x,z,y);//把n-1个盘子全部从X经过z移动到y柱上
    move(n,x,z);//偷偷把第n个盘子从x移动到z上
    hanoi(n-1,y,x,z);//把n-1个盘子从y经过x移动到z柱上，结束
}

int main()
{
    cin>>n;
    hanoi(n,'A','B','C');
    return 0;
}
```

# 队列

## 队列的基本概念

- **定义**
    只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表
- **逻辑结构**
    与线性表相同，仍为一对一关系
- **存储结构**
    用顺序队列或链队存储均可
- **运算规则**
    先进先出（FIFO）
- **实现方式**
    关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同

## 队列的实现

可用一个数组和两个变量优化为循环队列或者STL实现。比如循环队列`queue`，双端队列`deque`

## 循环队列

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822282090122.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822282793325.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822283596128.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822284293831.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822284949634.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822285572737.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822286223440.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822286918643.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822287543546.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822292245949.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822292867252.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822293406955.png)

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70-166822293940458.png)

### 循环队列的相关条件和公式

1. 队空条件：`rear==front`
2. 队满条件：`(rear+1) %QueueSIze==front`，其中QueueSize为循环队列的最大长度
3. 计算队列长度：`（rear-front+QueueSize）%QueueSize`
4. 入队：`（rear+1）%QueueSize`
5. 出队：`（front+1）%QueueSize`

## 链队列

```c++
typedef struct QNode{
   QElemType   data;
   struct Qnode  *next;
}Qnode, *QueuePtr;
typedef struct {
   QueuePtr  front;            //队头指针   
   QueuePtr  rear;             //队尾指针
}LinkQueue;  
```

链队列初始化

```c++
Status InitQueue (LinkQueue &Q){
   Q.front=Q.rear=(QueuePtr) malloc(sizeof(QNode)); 
    if(!Q.front) exit(OVERFLOW);
    Q.front->next=NULL;
     return OK;
}
```

销毁链队列

```c++
Status DestroyQueue (LinkQueue &Q){
   while(Q.front){
      Q.rear=Q.front->next;
      free(Q.front);
      Q.front=Q.rear;   }    
   return OK;
}
```

判断链队列是否为空

```c++
 Status QueueEmpty (LinkQueue Q)
{
    return (Q.front==Q.rear);                             
}
```

求链队列的头元素

```c++
Status GetHead (LinkQueue Q, QElemType &e){
   if(Q.front==Q.rear) return ERROR;
   e=Q.front->next->data;//有头结点
   return OK;
}
```

链队列入队

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/20200511172049371.png)

```c++
Status EnQueue(LinkQueue &Q,QElemType e){
    p=(QueuePtr)malloc(sizeof(QNode));
    if(!p) exit(OVERFLOW);
    p->data=e; p->next=NULL;
    Q.rear->next=p;
    Q.rear=p;
    return OK;
}
```

链队列出队

![在这里插入图片描述](%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.assets/20200511172039594.png)

## 链队列完整代码

```c++
Status DeQueue (LinkQueue &Q,QElemType &e){
   if(Q.front==Q.rear) return ERROR;
   p=Q.front->next;
   e=p->data;
   Q.front->next=p->next;
   if(Q.rear==p) Q.rear=Q.front;
   delete p;
   return OK;
}

#include "stdio.h"
#include "stdlib.h"
#include "io.h"
#include "math.h"
#include "time.h"

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20 /* 存储空间初始分配量 */

typedef int Status;

typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */

typedef struct QNode    /* 结点结构 */
{
    QElemType data;
    struct QNode *next;
} QNode, *QueuePtr;

typedef struct          /* 队列的链表结构 */
{
    QueuePtr front, rear; /* 队头、队尾指针 */
} LinkQueue;


Status visit(QElemType c)
{
    printf("%d ", c);
    return OK;
}


/* 构造一个空队列Q */
Status InitQueue(LinkQueue *Q)
{
    Q->front = Q->rear = (QueuePtr)malloc(sizeof(QNode));
    if (!Q->front)
        exit(OVERFLOW);
    Q->front->next = NULL;
    return OK;
}

/* 销毁队列Q */
Status DestroyQueue(LinkQueue *Q)
{
    while (Q->front)
    {
        Q->rear = Q->front->next;
        free(Q->front);
        Q->front = Q->rear;
    }
    return OK;
}

/* 将Q清为空队列 */
Status ClearQueue(LinkQueue *Q)
{
    QueuePtr p, q;
    Q->rear = Q->front;
    p = Q->front->next;
    Q->front->next = NULL;
    while (p)
    {
        q = p;
        p = p->next;
        free(q);
    }
    return OK;
}


/* 若Q为空队列,则返回TRUE,否则返回FALSE */
Status QueueEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return TRUE;
    else
        return FALSE;
}

/* 求队列的长度 */
int QueueLength(LinkQueue Q)
{
    int i = 0;
    QueuePtr p;
    p = Q.front;
    while (Q.rear != p)
    {
        i++;
        p = p->next;
    }
    return i;
}

/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */
Status GetHead(LinkQueue Q, QElemType *e)
{
    QueuePtr p;
    if (Q.front == Q.rear)
        return ERROR;
    p = Q.front->next;
    *e = p->data;
    return OK;
}


/* 插入元素e为Q的新的队尾元素 */
Status EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if (!s) /* 存储分配失败 */
        exit(OVERFLOW);
    s->data = e;
    s->next = NULL;
    Q->rear->next = s;  /* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */
    Q->rear = s;    /* 把当前的s设置为队尾结点，rear指向s，见图中② */
    return OK;
}

/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */
Status DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q->front == Q->rear)
        return ERROR;
    p = Q->front->next;     /* 将欲删除的队头结点暂存给p，见图中① */
    *e = p->data;           /* 将欲删除的队头结点的值赋值给e */
    Q->front->next = p->next; /* 将原队头结点的后继p->next赋值给头结点后继，见图中② */
    if (Q->rear == p)   /* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */
        Q->rear = Q->front;
    free(p);
    return OK;
}

/* 从队头到队尾依次对队列Q中每个元素输出 */
Status QueueTraverse(LinkQueue Q)
{
    QueuePtr p;
    p = Q.front->next;
    while (p)
    {
        visit(p->data);
        p = p->next;
    }
    printf("\n");
    return OK;
}

int main()
{
    int i;
    QElemType d;
    LinkQueue q;
    i = InitQueue(&q);
    if (i)
        printf("成功地构造了一个空队列!\n");
    printf("是否空队列？%d(1:空 0:否)  ", QueueEmpty(q));
    printf("队列的长度为%d\n", QueueLength(q));
    EnQueue(&q, -5);
    EnQueue(&q, 5);
    EnQueue(&q, 10);
    printf("插入3个元素(-5,5,10)后,队列的长度为%d\n", QueueLength(q));
    printf("是否空队列？%d(1:空 0:否)  ", QueueEmpty(q));
    printf("队列的元素依次为：");
    QueueTraverse(q);
    i = GetHead(q, &d);
    if (i == OK)
        printf("队头元素是：%d\n", d);
    DeQueue(&q, &d);
    printf("删除了队头元素%d\n", d);
    i = GetHead(q, &d);
    if (i == OK)
        printf("新的队头元素是：%d\n", d);
    ClearQueue(&q);
    printf("清空队列后,q.front=%u q.rear=%u q.front->next=%u\n", q.front, q.rear, q.front->next);
    DestroyQueue(&q);
    printf("销毁队列后,q.front=%u q.rear=%u\n", q.front, q.rear);
    return 0;

}
```

